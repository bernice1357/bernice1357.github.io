
            
        
        
            
        
            
        
        
            
        
            
        
        
            
        
            
        
        
            
        
            
        
        
            
        
            
        
        
            
        
            
        
        
            
        
            
        
        
            
        
        
            
        
            
        
        
            
        
        
            
        
        
            
        
        
            
        
        
            
        
        
            
        
        
            
        
        
            
        
        
            
        
        
            
        
        
            
        
        
            
        
        
            
        
        
            
        
        
            
        
        
            
        
        
            
        
        
            
        
        
            
        
        
            
        
        
            
        
        
            
        
        
            
        
        
            
        
        
            
        
            
        
        
            
        
        
            
        
        
            
        
        
        
        
        
        
        
        
        
        [{"categories":[{"LinkTitle":"2025","RelPermalink":"/categories/2025/"}],"content":" 這篇是上完 DeepLearning AI 上的課程 Building AI Applications with Haystack\r後的心得分享，圖片也都是來自課程影片\nHaystack 是什麼？ 他是一個可以讓製作 AI 應用程式的流程變得更簡單的一個工具，他可以完成各種文字生成的應用，像是問答、文件檢索、RAG 這些都可以做到。 我覺得他會取這個名字也是因為他就像稻草堆一樣可以把所有 AI 會使用到的套件包在一起，Haystack 裡有兩個最主要的元素 \u0026ndash; Pipeline 和 Components 進行整個流程。 其實在實作過程中我覺得他很像小學電腦課會學到的 scratch，把功能包裝成一塊塊積木再堆疊起來。\nPipeline、Component 介紹 1. Pipeline Pipeline 是由多個 Component 串接而成的處理流程，負責定義資料如何在元件間流動。\n他可以有各種流動的方式，可以設計成直線流程，也可以是複雜的有向無環圖，支援分支與條件路徑。\n2. Component Component 是 Haystack 的最小功能單位，每個 Component 都有明確的任務，例如文件轉換（PDFToTextConverter）、文本切割（DocumentSplitter）、檢索（Retriever）、嵌入向量生成（Embedder）、語言模型推理（PromptNode / Generator）等。它們就像積木一樣，可以透過輸入與輸出組合在一起，形成一個完整的工作流程。每個 component 都會各自的 inputs 和 outputs。\n實作 1. 建立一個 pipeline 架構 在這個例子中會展示如何將文件儲存進向量資料庫，這裡用到了四種 Component，分別是：\nConverter：將文件檔案轉換成 haystack 內部的格式。 Splitter：負責拆分文本。 Embedder：將文本轉換為 embedding。 Writer：將 embedding 寫進向量資料庫。 我們每次需要做的都是先定義 pipeline 和 component，將定義好的 component 放進 pipeline，再將他們依照順序串接起來。\nfrom haystack import Pipeline from haystack.components.converters.txt import TextFileToDocument from haystack.components.preprocessors.document_splitter import DocumentSplitter from haystack.components.embedders import OpenAIDocumentEmbedder from haystack.components.writers import DocumentWriter converter = TextFileToDocument() splitter = DocumentSplitter() embedder = OpenAIDocumentEmbedder() writer = DocumentWriter(document_store=document_store) indexing_pipeline = Pipeline() indexing_pipeline.add_component(\u0026#34;converter\u0026#34;, converter) indexing_pipeline.add_component(\u0026#34;splitter\u0026#34;, splitter) indexing_pipeline.add_component(\u0026#34;embedder\u0026#34;, embedder) indexing_pipeline.add_component(\u0026#34;writer\u0026#34;, writer) indexing_pipeline.connect(\u0026#34;converter\u0026#34;, \u0026#34;splitter\u0026#34;) indexing_pipeline.connect(\u0026#34;splitter\u0026#34;, \u0026#34;embedder\u0026#34;) indexing_pipeline.connect(\u0026#34;embedder\u0026#34;, \u0026#34;writer\u0026#34;) 執行上面的程式後就會看到 pipeline 的資訊，他會跟你說這個 pipeline 中有多少元素、怎麼連接這樣子。\n但如果真的要使用這個 pipeline 是需要透過 indexing_pipeline.run() 才能實現把文件放進去向量資料庫的實際功能喔！\nindexing_pipeline.run({\u0026#34;converter\u0026#34;: {\u0026#34;sources\u0026#34;: [\u0026#34;data/davinci.txt\u0026#34;]}}) 然後如果等到流程變得更複雜，也可以透過 indexing_pipeline.show() 看到圖像化的 pipeline 長什麼樣\n","permalink":"https://example.com/posts/haystack/","tags":[{"LinkTitle":"DeepLearning AI","RelPermalink":"/tags/deeplearning-ai/"},{"LinkTitle":"LLM","RelPermalink":"/tags/llm/"}],"title":"Haystack"},{"categories":[{"LinkTitle":"2024","RelPermalink":"/categories/2024/"}],"content":"實驗室這幾年都會參加 AI 的解題競賽，而這次的交流會是實驗室之前已經參加三年的 AIGO 競賽舉辦的，在成大舉行。這邊大概紀錄一下覺得值得紀錄的筆記：\n不是越新的模型效能越好，通常會拿來實際應用的模型通常是已經很多年的模型，因為他們通常會比較穩定。\nChatGPT 其實可以用網路幫你找資料，但他會因為懶就不幫你找，聽說是因為和人學的。這時候只要「情緒勒索」他，跟他說他的回答已經傷害到你的話 (因為模型好像有規定不能傷害到人)，他就會開始用網路找資料，超酷！\n在用 ChatGPT 對文章生成摘要時，不能跟他說要「總結」、「摘要」，因為它只會把長文盡可能縮成短文。所以要跟他說「筆記」，這才會把真正精華的東西記錄下來。\n","permalink":"https://example.com/posts/aigo%E4%BA%BA%E6%89%8D%E4%BA%A4%E6%B5%81%E6%9C%83/","tags":[{"LinkTitle":"心得","RelPermalink":"/tags/%E5%BF%83%E5%BE%97/"}],"title":"AIGO 人才交流會心得分享"},{"categories":[{"LinkTitle":"2024","RelPermalink":"/categories/2024/"}],"content":"前言 這篇整理了混淆矩陣、評估指標和一些相關的東西，對深度學習領域來說，這些東西應該是蠻重要的。\n混淆矩陣 (Confusion Matrix) 這個名字是翻譯過來的，所以會讓人有點不太懂為甚麼要取成 \u0026ldquo;混淆矩陣\u0026rdquo;，但如果改叫 \u0026ldquo;誤差矩陣\u0026rdquo; 應該就會比較好理解了。在做深度學習進行預測或是醫療領域做疾病檢測時，可能多多少少都會有一些 \u0026ldquo;誤差\u0026rdquo; 產生。\n以疾病檢測作為假設好了，一般來說做檢測想判斷的就是這個病人身上究竟是有病原體或是沒有病原體，但現在這個檢測方式可能會出差錯，導致把沒有生病的病人判斷為有生病，增加病人擔憂，也可能把有生病的病人判斷為沒有生病，增加社會恐慌，這就是標題所講的 \u0026ldquo;誤差\u0026rdquo;。\n上圖就是 Confusion Matrix 的示意圖，中間四格是根據預測結果和實際結果的不同所畫出來的表格，其中紅色字的表格是判斷錯誤的結果，這兩格在判斷標準好壞是個蠻重要的判斷依據。這四格可以組合出很多種的評估指標 (下一章節會講到)，但不會說哪一種評估指標才是最好的，因為每種情況都有最適合的指標。\n有個在做光學檢測的工廠，要判斷產品是否為瑕疵品，因為其實不太可能保證分類器一定沒有誤差，這時候就會盡量希望檢測標準的 FP (判斷產品是好的但其實有瑕疵) 越小越好，因為這樣比較不會被客戶退貨。\n評估指標 基本款 以下四種是最常見的\nAccuracy = (TP + TN) / (TP + FP + TN + FN): 這個就是把四種情況合併，計算出判斷正確的樣本佔比。 Recall = TP / (TP + FN): 計算出所有實際為正樣本的樣本中，預測正確者。 Specificity = TN / (TN + FP): 計算出所有實際為負樣本的樣本中，預測正確者。 Precision = TP / (TP + FP): 計算出所有預測為負樣本的樣本中，實際正確者。 進階款 ROC (Receiver Operating Characteristic) 講完評估指標，再來就要提到分類器在不同閾值 (Threshold/Cut-off) 下的決策品質，就是使用 ROC 去判斷，把檢測的輸出結果以曲線的方式呈現。\nx 軸是 1 - Specificity，錯誤接受率 / 偽陽性率 (FPR)。 y 軸是 Recall，正確接受率 / 真陽性率 (TPR)。 如上圖，他呈現的是在不同的 Specificity 下，判斷正確的機率為多少，\nAUC (Area Under the Curve) 再來要講的是 ROC 曲線下面積，這可以顯示出檢測的準確性。\n從上面這張可以看到，透過曲線下面積大小可以看出檢測的準確性高低。\n","permalink":"https://example.com/posts/%E6%A8%A1%E5%9E%8B%E8%A9%95%E4%BC%B0%E6%8C%87%E6%A8%99/","tags":[{"LinkTitle":"Note","RelPermalink":"/tags/note/"}],"title":"模型評估指標"},{"categories":[{"LinkTitle":"2024","RelPermalink":"/categories/2024/"}],"content":"前言 這篇整理了一些在處理不平衡資料集會進行的常見處理方式。\n蒐集新特徵 抽樣方法：透過個體的複製與刪除，創造出比較平衡的資料集合 Oversampling：隨機複製陽性個體，使陽性與陰性在訓練集合的比例達到 1:1，這種方法最大的缺點是很容易讓 Specificity 下降 Undersampling：隨機刪除陰性個體，使陽性與陰性在訓練集合的比例達到 1:1，這種方法最大的缺點是很容易缺失某些陰性個體的資訊\n產生合成樣本 (Synthetic Sample) 根據原本陽性樣本的分佈特徵，模擬出很類似的新陽性樣本，比如SMOTE / AdaSyn 等利用「最近鄰點」(Nearest Neighbors) 為出發的方法產生新資料 利用貝氏網絡 (Bayesian Network) 產生具有相似變數結構的新資料\nGAN：利用生成與對抗模型產生相似分配的資料 成本導向的機器學習模型 (Cost-sensitive Classification)： 將一般機器學習的損失函數 (loss function) 改為成本導向的損失函數\n","permalink":"https://example.com/posts/%E9%9D%A2%E5%B0%8D%E4%B8%8D%E5%B9%B3%E8%A1%A1%E8%B3%87%E6%96%99%E9%9B%86%E7%9A%84%E8%99%95%E7%90%86%E6%96%B9%E5%BC%8F/","tags":[{"LinkTitle":"Note","RelPermalink":"/tags/note/"}],"title":"面對不平衡 dataset 的處理方式"},{"categories":[{"LinkTitle":"2024","RelPermalink":"/categories/2024/"}],"content":"我記得一開始使用 Hugo 的時候是大四上，一開始在找有沒有方便好用的架站工具，結果就找到了這個。只需要選擇喜歡的網頁模板，再根據參數打上資料就好，超級方便！！但如果要加上一些額外功能還是需要自己作一些調整，這篇整理了在使用 Hugo 的過程中的一些經驗。\n前情提要 因為我在做網站時有打算增加自定義 css，所以有先把 themes/\u0026lt;your_theme\u0026gt;/layouts/partials/head.html 新增到 layouts\\partials\\head.html。\n1. 增加 LaTex 數學式 Hugo 教學\r這裡的步驟 90% 是參考官網的教學，可以直接使用，但我在使用時在 Step 3 遇到了問題，這樣寫實際上會造成網頁全部空白，我最後是在 /layouts/partials/head.html 新增 Step 3 的程式碼。\n2. 改變 blockquote 顏色 (自定義 css) 首先在 /hugo.toml 輸入下面這一段，這邊的參數 custom.css 需要把之後新增的 css 檔案全部加進去。\n[params] custom_css = [\u0026#34;/css/custom.css\u0026#34;] 接著在 /layouts/partials/head.html 加入下面這段，加在哪都可以。\n{{ range .Site.Params.custom_css -}} \u0026lt;link rel=\u0026#34;stylesheet\u0026#34; href=\u0026#34;{{ . | absURL }}\u0026#34;\u0026gt; {{- end }} 最後到 /static/css/custom.css 新增自己要的 css 就大功告成！\n3. 文字改變對齊 可以參考 這篇\r的內容，但我怕他連結不見還是再這裡紀錄一次。\n在 /layouts/shortcodes/align.html (沒有的話要自己新增) 加入下面的程式:\n\u0026lt;!-- 文件位置：~/layouts/shortcodes/align.html --\u0026gt; \u0026lt;p style=\u0026#34;text-align:{{ index .Params 0 }}\u0026#34;\u0026gt;{{ index .Params 1 | markdownify }}\u0026lt;/p\u0026gt; 接著就可以在 markdown 檔案中加入不同文字對齊格式了！(這邊需要注意使用時要把 { 和 \u0026lt; 中間的空格移除)\n{{ \u0026lt; align left \u0026#34;文字居左\u0026#34; \u0026gt; }} {{ \u0026lt; align center \u0026#34;文字居中\u0026#34; \u0026gt; }} {{ \u0026lt; align right \u0026#34;文字居右\u0026#34; \u0026gt; }} ","permalink":"https://example.com/posts/hugo-%E7%9B%B8%E9%97%9C%E7%AD%86%E8%A8%98/","tags":[{"LinkTitle":"Hugo","RelPermalink":"/tags/hugo/"},{"LinkTitle":"Note","RelPermalink":"/tags/note/"}],"title":"Hugo 使用上的一些筆記"},{"categories":[{"LinkTitle":"2024","RelPermalink":"/categories/2024/"}],"content":"前言 今天介紹的這篇是 vision transformer 領域的一篇論文，作者的主要貢獻是提出 Bi-Level Routing Attention， 這種 attention 使得 query 可以動態地抓取關聯 key-value pairs，而且計算複雜度比起其他的 attention 要低得多。 這個模型可用於多種影像任務上。\n如果對 attention 比較不熟悉的話，可以先到這篇文章瞭解喔\u0026#x1f609;\n其他模型的設計方法 首先介紹各種不同的 attention 機制，上面四種 attention 分別是 Local Attention、Axial Attention、Dilated Attention 和 Deformable Attention。而示意圖中的星星符號表示目標 token 的位置，綠色和黃色的小格子則代表該 token 要找出對應的 key-value pairs 的範圍，所以這四種 attention 其實比起最原始的 Vanilla Attention 還要節省了很多比對 key-value pairs 的時間成本。\n而今天要介紹的 attention 比起上面的方法還要節省更多計算成本，而且計算起來更靈活。\nBi-Level Routing Attention 這張是 Bi-Level Routing Attention 方法的偽代碼，總共分為如下的三個部分：\n這篇有個不同的點要先說明：\n在以往的 attention 中，通常輸入只會被分割成很多 patchs，但是這篇的做法會拆成 patchs(or tokens) 和 regions(or local windows)兩種 level，在attention 外面其實已經做好 patch 的拆分了(Patch Embedding \u0026amp; Patch Merging)。\n第一部分：Region partition and input projection 這個部分主要是對輸入進行前處理。\n第一行可以看到 patchify() 將輸入切割成多個 regions，總共有 S^2 個 regions，每個 region 共有 (H/S)*(W/S) 個小 tokens，也就是 HW/S^2 個 tokens。所以在第一行程式碼上的註解，x 的形狀從 (H, W, C) 被改變為 (S^2, HW/S^2, C)，也就代表了 (region 的數量, token 的數量, channel)。\n再來第二行就是對於每個小 token 各取他們的 query、key、value 出來。\n第二部分：Region-to-region routing with directed graph 第一行分別取每個 region 的 query 和 key，計算出來的結果就是 query_r 和 key_r，接著第二行再根據 query_r 和 key_r 計算所有 regions 的關聯性 (和 attention 計算注意力權重的方法是一樣的)，最後第三行每個 region 都會分別取前 k 個和該 region 最相關的 region，也就是 I_r。\n第三部分：Token-to-token attention 現在每個 region 都有他們各自最相關的前 k 個 regions 了，接下來我們就要回到 token level 的計算，讓每個 token 在計算 attention 時可以只和前 k 個的區域進行計算，不需要和所有 token 一起計算。\n以下是第三部分的示意圖，藍色的部分是目標 query，黃色的部分是由第二部分所計算出來的前 k 個區域，再來對 query 和 key_g 做注意力權重的計算， 基本上和原始的 attention 算法是一模一樣，比較特別的是，作者在 attention 最後面加上了 LCE(Local Context Enhancement)\r。\nBiformer 接下來是模型架構的部分，整體模型是一個常見的四層金字塔結構，像是在 Swin transformer 裡也是用這樣的架構。圖中四個 block 的上方表示是進入 Biformer block 的輸入大小， 會有不同的大小是因為 patch embedding 和 patch merging 會做 patch 的拆分。其中這四個部分的 k 分別是 1, 4, 16, S^2， 後面 k 越取越大是因為 token 會隨著輸入下採樣越來越小，會越來越相似，所以需要取多一點才能比較容易判斷。\nPatch Embedding： Patch merging： 作者設計了三種大小的模型架構，分別是 Tiny、Small、Base 三種，Channel 就可以把他想像成是模型的寬度，Blocks 則是模型的長度。\n在 Biformer Block 裡的架構：\n實驗 這篇論文分別在影像分類、物件偵測、語義分割、實例分割四種任務上進行實驗，\n影像分類 使用 ImageNet-1K dataset 進行實驗，其中有額外加上 tokem labeling 的準確率是最高的。\n物件偵測 \u0026amp; 實例分割 使用 COCO2017 dataset 進行實驗。\n語義分割 使用 ADE20K dataset 進行實驗。\n消融實驗 針對架構中四個層不同的 topk 和分割 region 的參數 S，這邊做了消融實驗。 作者提到由於 padding 會造成計算成本提高和模型效能下降的問題，因此在影像分類的任務中將 S 設定為 7(在此任務中的輸入大小是 224x224x3)， 在物件偵測任務中設定為 16，語義分割中則是設定為 8。\n","permalink":"https://example.com/posts/biformer/","tags":[{"LinkTitle":"Vision Trasformer","RelPermalink":"/tags/vision-trasformer/"},{"LinkTitle":"Paper","RelPermalink":"/tags/paper/"}],"title":"BiFormer: Vision Transformer with Bi-Level Routing Attention"},{"categories":[{"LinkTitle":"2024","RelPermalink":"/categories/2024/"}],"content":"前言 這篇論文是在 2024 年在 IEEE 發表的，這篇是影像復原領域的，主要任務是去除圖片中的雨水紋 (消除雜訊)，提出了一個的模型叫做 MFDNet， 這個模型結合了傳統 CNN 和 Transformer 的優點，還有 Asymmetrical dual-path representation 這個特殊的架構，可以幫助更好地分解原本的圖片和雨水紋。\nHRM (Hybrid Representation Module) 這邊要先提到 HRM 的架構，他算是這篇論文裡面最重要的一個部分，在整個模型裡用了非常多次，主要是在執行分解雨水紋和原始圖片兩種特徵。整體架構是上面右圖，可以看到他分為上下兩個通道同步進行，而這就是在前言所提到的 \u0026ldquo;Asymmetrical dual-path representation\u0026quot;，上面處理的是雨水紋的特徵，下面處理的是原始圖片的特徵。\n再來以左右方向來看這個 module，他分成 HEFB(Hybrid Feature Extraction Block) 和 CRB(Coupled Representation Block) 兩個部分，接下來下面會以左右方向來介紹這個 module。\nHEFB (Hybrid Representation Module) 首先先看到上通道的部分，又可以細分為 CAB(Channel Attention Block) 和 Trasformer Block 兩個部分：\n在這個模型裡特徵會分成雨水紋和原始圖片兩個部分，最一開始拆分兩種特徵是在 Patch Embedding Module 處理的，下面會介紹。\nCAB: 如上 (a) 圖，編碼來自局部影像結構的訊息，並調整不同 channel 間的權重，並補充本地互動的不足。 Channel Attention 其實是一種調整不同 channel 權重的方式，如下圖，中間會經過 Global pooling、Down sampling、fully connection 得到所有 channel 的權重後，在和最一開始的 features 相乘，就完成調整權重的處理。 Trasformer Block: 如上 (b) 圖，目的是為了關注雨的樣式，並區分雨條紋和背景的資訊。在 HRM 中串聯了 4 個 Trasformer Block，其中在 Trasformer Block 前面做了 down sampling (只在進入 Trasformer Block 前做) 是因為 transformer 會消耗掉比較大的計算成本。 在 Trasformer Block 中有個 Head-FC ，作者的解釋是這樣: We set up a fully connected layer across head dimensions to enhance communication among the heads.\n接著是下通道的部分，這邊就是做 identity mapping 和 CAB 的處理而已，identity mapping 在論文中沒有細講。\nCRB (Coupled Representation Block) 作者看到以往的論文將兩種特徵分開處理，但模型表現不好，因此把兩種特徵混合在一起做特徵萃取，中間有很多條交叉的通道就是混合的步驟。\n中間的 weights 通道的架構是粉色箭頭指向的圖，這一塊主要是想調整另一個特徵的權重，因為如果直接把另一個特徵直接加進去相乘可能反而會被影響太多，因此把它調整的小一點讓他的影響力不會這麼大。\n$z_R$、$z_B$: $g_R$、$g_B$ 是前面 HEFB 最後的輸出，接下來看到中間 $z_B$ 的地方，有兩個箭頭指向 $z_B$，代表有兩個輸入，這邊作者把改變過權重的輸入 (weights)和 $g_R$ 做相乘，同理的 $g_B$ 也是一樣的處理方式。\n輸出結果視覺化 上圖可以看到包含雨水紋的圖片以及模型將雨水紋移除的輸出，$z_R$、$z_B$ 是 CRB 中的視覺化圖像。\nMFDNet 上圖是 MFDNet 的架構，我用粉紅色框框把架構拆解成了三個部分，分別是捕捉多尺度特徵、分解雨水紋和原始圖片特徵、重組雨水紋和原始圖片。\n捕捉多尺度特徵 首先看到的是最左邊的部分，輸入圖片進入模型後會先到 Patch Embedding Module，這邊就等於是做了下採樣的處理，這邊分成了三種維度大小，分別是原尺寸、1/2、1/4，進入 HRM 後，會把\n分解雨水紋和原始圖片 這個部份其實就是串聯 3 個 HRM Module，是經過消融實驗得到的。\n重組雨水紋和原始圖片 這邊會多這個區塊主要是為了之後 loss function 要判斷模型效能而放的，所以其實整體模型就是由很多的 HRM 組合而成而已。\nObjective function (Loss function) 整個 Loss function 包含預測原始圖片的 loss 和預測雨水紋的 loss 兩個部分，裡面主要由三個函式組成:\n$\\mathcal{L}_{ssim}()$ : Structural SIMilarity，指導合作網絡學習更多恢復相似結構細節 $\\mathcal{L}_{Char}()$ : Charbonnier penalty function，移除異常值、保留高頻訊息 $\\mathcal{L}_{edges}()$ : Laplacian Edge Extraction，偵測特徵的邊緣 這篇論文的 loss 是用監督式學習的方式，因為在 Char() 和 edges() 中，$I_B*$ 和 $I_B$ 分別代表 Ground truth 和預測結果，它並不是用自己預測的結果再去調整參數，所以不是自監督式學習。\n實驗 在影像復原領域的資料集可以根據有無 ground truth 進行分類:\n1. 有 Ground Truth 這種是把原本沒有雨水紋的圖像人工加上雨水紋路(雜訊)\n以下面兩種評估指標評斷效能:\nPeak Signal to Noise Ratio (PSNR)：評估兩圖像間的相似性 Structural SIMilarity (SSIM)：比較兩圖像間的亮度、對比度、結構 2. 無 Ground Truth 這種是自然界出現的下雨影像，所以不會有 ground truth\nNatural Image Quality Evaluator (NIQE) Spatial-Spectral Entropy-based Quality (SSEQ) 消融實驗 1. Loss function 中不同權重參數的比較 2. HRM 和 Transformer block 數量比較 ","permalink":"https://example.com/posts/deraining/","tags":[{"LinkTitle":"Denoising","RelPermalink":"/tags/denoising/"},{"LinkTitle":"Paper","RelPermalink":"/tags/paper/"}],"title":"Multi-Scale Fusion and Decomposition Network for Single Image Deraining"},{"categories":[{"LinkTitle":"2022","RelPermalink":"/categories/2022/"}],"content":"這次到中興大學參加了「學術倫理-抄襲與引用面面觀」講座，聽到了蠻多值得紀錄的東西，就整理了這個筆記。\n常見的論文抄襲例子 直接抄襲 (複製貼上)\n這個蠻好理解的，就是將其他論文的句子原封不動的寫進自己的論文，或是把他人寫的句子拆分成不同段寫到自己的論文裡也算是抄襲。 如果想要解決這個問題，可以在文章中使用“”將引用到的句子標記出來，然後在“”的後面用()標註是引用參考文獻的哪篇論文，參考文獻都會標號碼嘛，標記是哪篇就行了。\n在未引用的情況下改寫\n簡單來說，就是把別人的想法用自己的話改寫，雖然句子看起來是不一樣的，但意思一模一樣，這樣也算抄襲。\n圖像抄襲\n把其他論文的圖表截圖，使用在自己的文章中，最好是自己重畫一張，否則就要標記圖片來源。\n將素材誤解為常識\n這點比較不算是抄襲。在某些領域，有些知識對那塊領域的人來說是再基本不過的事，但對於其他領域的人來說可能是一個從來沒聽過的知識，有些人可能會因此將前情提要寫得過於簡陋，導致不熟悉該領域的讀者無法理解內容。\n在引用上的好習慣 讀的論文最好是第一手的資料\n因為論文在被引用的過程中，原文想表達的意思可能會被扭曲、誤解，導致讀到第二手、第三手資料的讀者也跟著誤解原文的意思。為了避免這種情況，還是盡量以第一手的論文為優先。\n引用儘量使用期刊文章\n這點是因為\nTurnitin 抄襲比對系統，他不會說論文內容重複的地方在哪邊，只會說比對後有重複的百分比。\n字詞翻譯 CC(Creative Common):創用CC Plagiarism：抄襲 Paraphrasing：文意引用 ","permalink":"https://example.com/posts/%E6%8A%84%E8%A5%B2%E5%BC%95%E7%94%A8/","tags":[{"LinkTitle":"Note","RelPermalink":"/tags/note/"}],"title":"⟪抄襲與引用⟫ 講座筆記"},{"categories":[{"LinkTitle":"Github","RelPermalink":"/categories/github/"}],"content":"在開發過程中，我們經常需要將程式碼推送到 GitHub。使用 SSH Key 可以讓我們安全且方便地進行 Git 操作，而不需要每次都輸入帳號密碼。\n什麼是 SSH Key SSH Key 是一種安全的認證方式，它使用一對金鑰：\n私鑰 (Private Key)：保存在本地電腦，絕對不能分享給他人 公鑰 (Public Key)：可以分享，上傳到 GitHub 產生 SSH Key 1. 檢查現有的 SSH Key # 查看是否已存在 SSH Key ls -al ~/.ssh 如果看到 id_rsa 和 id_rsa.pub 或 id_ed25519 和 id_ed25519.pub，表示已有 SSH Key。\n2. 產生新的 SSH Key # 使用 Ed25519 演算法 (推薦) ssh-keygen -t ed25519 -C \u0026#34;your_email@example.com\u0026#34; # 如果系統不支援 Ed25519，使用 RSA ssh-keygen -t rsa -b 4096 -C \u0026#34;your_email@example.com\u0026#34; 執行後會詢問：\n儲存位置：直接按 Enter 使用預設位置 Passphrase：可設定密碼增加安全性，或直接按 Enter 跳過 將 SSH Key 加入到 SSH Agent # 啟動 SSH Agent eval \u0026#34;$(ssh-agent -s)\u0026#34; # 將私鑰加入到 SSH Agent ssh-add ~/.ssh/id_ed25519 # 或者如果使用 RSA ssh-add ~/.ssh/id_rsa 將公鑰加入到 GitHub 1. 複製公鑰內容 # 複製 Ed25519 公鑰 cat ~/.ssh/id_ed25519.pub # 或複製 RSA 公鑰 cat ~/.ssh/id_rsa.pub 2. 在 GitHub 上新增 SSH Key 登入 GitHub 點擊右上角頭像 \u0026gt; Settings 左側選單點擊 \u0026ldquo;SSH and GPG keys\u0026rdquo; 點擊 \u0026ldquo;New SSH key\u0026rdquo; Title：輸入描述性名稱（如：My MacBook） Key：貼上剛才複製的公鑰內容 點擊 \u0026ldquo;Add SSH key\u0026rdquo; 測試 SSH 連線 ssh -T git@github.com 成功的話會看到類似訊息：\nHi username! You\u0026#39;ve successfully authenticated, but GitHub does not provide shell access. 建立靜態網頁專案 1. 建立 HTML 檔案 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;zh-TW\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width, initial-scale=1.0\u0026#34;\u0026gt; \u0026lt;title\u0026gt;我的靜態網頁\u0026lt;/title\u0026gt; \u0026lt;style\u0026gt; body { font-family: Arial, sans-serif; max-width: 800px; margin: 0 auto; padding: 20px; background-color: #f5f5f5; } .container { background-color: white; padding: 40px; border-radius: 10px; box-shadow: 0 2px 10px rgba(0,0,0,0.1); } h1 { color: #333; text-align: center; } p { line-height: 1.6; color: #666; } \u0026lt;/style\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div class=\u0026#34;container\u0026#34;\u0026gt; \u0026lt;h1\u0026gt;歡迎來到我的網頁\u0026lt;/h1\u0026gt; \u0026lt;p\u0026gt;這是使用 GitHub Pages 建立的靜態網頁。\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;透過 SSH Key 我可以安全地將程式碼推送到 GitHub。\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 2. 初始化 Git 專案 # 初始化 Git 儲存庫 git init # 建立 index.html # (貼上上面的 HTML 程式碼) # 加入檔案到暫存區 git add . # 提交變更 git commit -m \u0026#34;初始化靜態網頁\u0026#34; 推送到 GitHub 1. 在 GitHub 建立儲存庫 登入 GitHub 點擊右上角的 \u0026ldquo;+\u0026rdquo; \u0026gt; \u0026ldquo;New repository\u0026rdquo; Repository name：輸入專案名稱 設定為 Public（GitHub Pages 免費版需要公開儲存庫） 不要勾選 \u0026ldquo;Initialize this repository with a README\u0026rdquo; 點擊 \u0026ldquo;Create repository\u0026rdquo; 2. 連接本地儲存庫到 GitHub # 加入遠端儲存庫（使用 SSH） git remote add origin git@github.com:username/repository-name.git # 推送程式碼到 GitHub git branch -M main git push -u origin main 啟用 GitHub Pages 進入 GitHub 儲存庫頁面 點擊 \u0026ldquo;Settings\u0026rdquo; 標籤 左側選單向下滾動找到 \u0026ldquo;Pages\u0026rdquo; Source 選擇 \u0026ldquo;Deploy from a branch\u0026rdquo; Branch 選擇 \u0026ldquo;main\u0026rdquo; 資料夾選擇 \u0026ldquo;/ (root)\u0026rdquo; 點擊 \u0026ldquo;Save\u0026rdquo; 幾分鐘後，網頁就會在 https://username.github.io/repository-name 上線。\n更新網頁內容 # 修改檔案後 git add . git commit -m \u0026#34;更新網頁內容\u0026#34; git push origin main 推送後，GitHub Pages 會自動更新網站內容。\n常見問題解決 Permission denied (publickey) # 確認 SSH Key 已加入 SSH Agent ssh-add -l # 如果沒有，重新加入 ssh-add ~/.ssh/id_ed25519 測試不同的 SSH Key # 測試特定的 SSH Key ssh -i ~/.ssh/id_ed25519 -T git@github.com 設定 SSH Config 建立 ~/.ssh/config 檔案：\nHost github.com\rHostName github.com\rUser git\rIdentityFile ~/.ssh/id_ed25519 自動化部署腳本 建立部署腳本 deploy.sh：\n#!/bin/bash echo \u0026#34;開始部署...\u0026#34; # 加入所有變更 git add . # 提交變更 echo \u0026#34;請輸入提交訊息：\u0026#34; read commit_message git commit -m \u0026#34;$commit_message\u0026#34; # 推送到 GitHub git push origin main echo \u0026#34;部署完成！\u0026#34; echo \u0026#34;網站將在幾分鐘後更新：https://username.github.io/repository-name\u0026#34; 使用方式：\nchmod +x deploy.sh ./deploy.sh 透過 SSH Key 的設定，我們可以安全且便利地管理 GitHub 儲存庫，並輕鬆地部署靜態網頁到 GitHub Pages。\n","permalink":"https://example.com/posts/%E5%9C%A8-github-%E4%B8%8A%E4%BD%BF%E7%94%A8-ssh-key-push-%E9%9D%9C%E6%85%8B%E7%B6%B2%E9%A0%81%E5%B1%95%E7%A4%BA/","tags":[],"title":"在 Github 上使用 SSH Key push 靜態網頁展示"},{"categories":[{"LinkTitle":"2022","RelPermalink":"/categories/2022/"}],"content":"前言 這篇把之前購買網域並連到個人網站上的一些心得整理出來，但每個人買網域的地方都不太一樣 (我是在 pchome 買的)，步驟可能也會不太一樣\n買網域 我當初會到 pchome 買，主要還是因為他比較便宜\n","permalink":"https://example.com/posts/%E5%A6%82%E4%BD%95%E8%B3%BC%E8%B2%B7%E8%87%AA%E5%B7%B1%E7%9A%84-dns/","tags":[{"LinkTitle":"Note","RelPermalink":"/tags/note/"},{"LinkTitle":"Dns","RelPermalink":"/tags/dns/"}],"title":"如何購買自己的 DNS"},{"categories":[{"LinkTitle":"2022 鐵人賽系列","RelPermalink":"/categories/2022-%E9%90%B5%E4%BA%BA%E8%B3%BD%E7%B3%BB%E5%88%97/"}],"content":"在 Node.js 的生態系中，npm 和 nvm 是兩個非常重要的工具。npm 是套件管理器，而 nvm 是 Node.js 版本管理器。\n什麼是 npm npm 全名是 Node Package Manager，是 Node.js 的套件管理器。它讓開發者可以輕鬆地安裝、更新、移除和管理 JavaScript 套件。\nnpm 的主要功能 套件安裝：安裝第三方套件 依賴管理：管理專案的依賴關係 腳本執行：執行自定義的腳本命令 版本管理：管理套件的版本 npm 基本命令 初始化專案 # 建立新的 package.json 檔案 npm init # 使用預設設定快速初始化 npm init -y 安裝套件 # 安裝套件並加入 dependencies npm install \u0026lt;package-name\u0026gt; npm i \u0026lt;package-name\u0026gt; # 安裝套件並加入 devDependencies npm install \u0026lt;package-name\u0026gt; --save-dev npm i \u0026lt;package-name\u0026gt; -D # 全域安裝套件 npm install \u0026lt;package-name\u0026gt; --global npm i \u0026lt;package-name\u0026gt; -g # 安裝特定版本的套件 npm install \u0026lt;package-name\u0026gt;@\u0026lt;version\u0026gt; 移除套件 # 移除套件 npm uninstall \u0026lt;package-name\u0026gt; npm remove \u0026lt;package-name\u0026gt; # 移除全域套件 npm uninstall \u0026lt;package-name\u0026gt; --global 更新套件 # 更新所有套件 npm update # 更新特定套件 npm update \u0026lt;package-name\u0026gt; # 檢查過期的套件 npm outdated 其他實用命令 # 查看已安裝的套件 npm list npm ls # 查看套件資訊 npm info \u0026lt;package-name\u0026gt; # 執行 package.json 中定義的腳本 npm run \u0026lt;script-name\u0026gt; # 清除 npm 快取 npm cache clean --force package.json 檔案 package.json 是專案的配置檔案，包含了專案的基本資訊和依賴管理：\n{ \u0026#34;name\u0026#34;: \u0026#34;my-project\u0026#34;, \u0026#34;version\u0026#34;: \u0026#34;1.0.0\u0026#34;, \u0026#34;description\u0026#34;: \u0026#34;我的專案描述\u0026#34;, \u0026#34;main\u0026#34;: \u0026#34;index.js\u0026#34;, \u0026#34;scripts\u0026#34;: { \u0026#34;start\u0026#34;: \u0026#34;node index.js\u0026#34;, \u0026#34;dev\u0026#34;: \u0026#34;nodemon index.js\u0026#34;, \u0026#34;test\u0026#34;: \u0026#34;jest\u0026#34;, \u0026#34;build\u0026#34;: \u0026#34;webpack\u0026#34; }, \u0026#34;dependencies\u0026#34;: { \u0026#34;express\u0026#34;: \u0026#34;^4.18.0\u0026#34;, \u0026#34;lodash\u0026#34;: \u0026#34;^4.17.21\u0026#34; }, \u0026#34;devDependencies\u0026#34;: { \u0026#34;nodemon\u0026#34;: \u0026#34;^2.0.15\u0026#34;, \u0026#34;jest\u0026#34;: \u0026#34;^28.0.0\u0026#34; }, \u0026#34;keywords\u0026#34;: [\u0026#34;javascript\u0026#34;, \u0026#34;node\u0026#34;], \u0026#34;author\u0026#34;: \u0026#34;Your Name\u0026#34;, \u0026#34;license\u0026#34;: \u0026#34;MIT\u0026#34; } 什麼是 nvm nvm 全名是 Node Version Manager，是 Node.js 的版本管理器。它讓開發者可以在同一台電腦上安裝和切換不同版本的 Node.js。\n為什麼需要 nvm 多版本需求：不同專案可能需要不同版本的 Node.js 版本測試：測試程式在不同 Node.js 版本下的相容性 升級安全：可以安全地升級或降級 Node.js 版本 nvm 安裝 macOS/Linux # 使用 curl 安裝 curl -o- https://raw.githubusercontent.com/nvm-sh/nvm/v0.39.0/install.sh | bash # 或使用 wget 安裝 wget -qO- https://raw.githubusercontent.com/nvm-sh/nvm/v0.39.0/install.sh | bash # 重新載入終端機設定 source ~/.bashrc Windows Windows 使用者可以安裝 nvm-windows：\n從 nvm-windows GitHub\r下載安裝包 執行安裝程式 nvm 基本命令 # 查看 nvm 版本 nvm --version # 列出所有可安裝的 Node.js 版本 nvm list-remote nvm ls-remote # 列出已安裝的 Node.js 版本 nvm list nvm ls # 安裝最新版本的 Node.js nvm install node # 安裝特定版本的 Node.js nvm install 16.18.0 # 安裝最新的 LTS 版本 nvm install --lts # 切換到特定版本 nvm use 16.18.0 # 設定預設版本 nvm alias default 16.18.0 # 查看目前使用的版本 nvm current # 移除特定版本 nvm uninstall 14.20.0 實際使用場景 專案 A 使用 Node.js 16 cd project-a nvm use 16 npm install npm start 專案 B 使用 Node.js 18 cd project-b nvm use 18 npm install npm start 使用 .nvmrc 檔案 在專案根目錄建立 .nvmrc 檔案：\n16.18.0 然後在專案目錄執行：\nnvm use # 自動切換到 .nvmrc 指定的版本 npm vs yarn 除了 npm，還有其他套件管理器如 yarn：\n特性 npm yarn 安裝速度 較慢 較快 離線安裝 支援 支援 鎖定檔案 package-lock.json yarn.lock 安全性 良好 良好 最佳實務 使用 .nvmrc：為每個專案指定 Node.js 版本 鎖定版本：提交 package-lock.json 到版本控制 定期更新：定期檢查和更新套件版本 區分依賴：正確區分 dependencies 和 devDependencies 使用 npm audit：定期檢查安全性漏洞 # 檢查安全性漏洞 npm audit # 自動修復漏洞 npm audit fix ","permalink":"https://example.com/posts/day21-npmnvm/","tags":[],"title":"Day21 - npm\u0026nvm"},{"categories":[{"LinkTitle":"2022 鐵人賽系列","RelPermalink":"/categories/2022-%E9%90%B5%E4%BA%BA%E8%B3%BD%E7%B3%BB%E5%88%97/"}],"content":"在網頁開發中，我們經常需要為 DOM 元素添加事件監聽器。但是當頁面中有大量元素需要相同的事件處理時，為每個元素單獨添加監聽器會造成性能問題。這時候就需要用到事件代理（Event Delegation）。\n什麼是事件代理 事件代理是一種事件處理技術，它利用了事件冒泡的原理，將事件監聽器添加到父元素上，而不是直接添加到目標元素上。當子元素觸發事件時，事件會冒泡到父元素，父元素的監聽器就可以處理這個事件。\n事件冒泡機制 在了解事件代理前，我們先來了解事件冒泡：\n\u0026lt;div id=\u0026#34;parent\u0026#34;\u0026gt; \u0026lt;button id=\u0026#34;child\u0026#34;\u0026gt;點擊我\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; document.getElementById(\u0026#39;parent\u0026#39;).addEventListener(\u0026#39;click\u0026#39;, () =\u0026gt; { console.log(\u0026#39;父元素被點擊\u0026#39;); }); document.getElementById(\u0026#39;child\u0026#39;).addEventListener(\u0026#39;click\u0026#39;, () =\u0026gt; { console.log(\u0026#39;子元素被點擊\u0026#39;); }); 當我們點擊按鈕時，會看到：\n子元素被點擊\r父元素被點擊 這就是事件冒泡，事件從目標元素開始，向上冒泡到父元素。\n傳統方法的問題 假設我們有一個列表，每個項目都需要點擊事件：\n\u0026lt;ul id=\u0026#34;list\u0026#34;\u0026gt; \u0026lt;li\u0026gt;項目 1\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;項目 2\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;項目 3\u0026lt;/li\u0026gt; \u0026lt;!-- 更多項目... --\u0026gt; \u0026lt;/ul\u0026gt; 傳統做法：\nconst items = document.querySelectorAll(\u0026#39;#list li\u0026#39;); items.forEach(item =\u0026gt; { item.addEventListener(\u0026#39;click\u0026#39;, handleClick); }); function handleClick(event) { console.log(\u0026#39;點擊了:\u0026#39;, event.target.textContent); } 這種做法的問題：\n性能問題：為每個元素都添加監聽器 記憶體消耗：大量的監聽器佔用記憶體 動態元素問題：新添加的元素沒有監聽器 使用事件代理 事件代理的做法：\nconst list = document.getElementById(\u0026#39;list\u0026#39;); list.addEventListener(\u0026#39;click\u0026#39;, function(event) { // 檢查點擊的是否為 li 元素 if (event.target.tagName === \u0026#39;LI\u0026#39;) { console.log(\u0026#39;點擊了:\u0026#39;, event.target.textContent); } }); 事件代理的優點 提升性能：只需要一個監聽器 節省記憶體：減少監聽器的數量 支援動態元素：新添加的元素自動擁有事件處理 簡化代碼：統一的事件處理邏輯 實際應用範例 範例 1：動態列表 \u0026lt;div id=\u0026#34;todo-app\u0026#34;\u0026gt; \u0026lt;input type=\u0026#34;text\u0026#34; id=\u0026#34;new-item\u0026#34; placeholder=\u0026#34;輸入新項目\u0026#34;\u0026gt; \u0026lt;button id=\u0026#34;add-btn\u0026#34;\u0026gt;添加\u0026lt;/button\u0026gt; \u0026lt;ul id=\u0026#34;todo-list\u0026#34;\u0026gt; \u0026lt;li\u0026gt; \u0026lt;span\u0026gt;學習 JavaScript\u0026lt;/span\u0026gt; \u0026lt;button class=\u0026#34;delete-btn\u0026#34;\u0026gt;刪除\u0026lt;/button\u0026gt; \u0026lt;/li\u0026gt; \u0026lt;li\u0026gt; \u0026lt;span\u0026gt;學習 CSS\u0026lt;/span\u0026gt; \u0026lt;button class=\u0026#34;delete-btn\u0026#34;\u0026gt;刪除\u0026lt;/button\u0026gt; \u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; \u0026lt;/div\u0026gt; const todoList = document.getElementById(\u0026#39;todo-list\u0026#39;); const newItemInput = document.getElementById(\u0026#39;new-item\u0026#39;); const addBtn = document.getElementById(\u0026#39;add-btn\u0026#39;); // 使用事件代理處理刪除按鈕 todoList.addEventListener(\u0026#39;click\u0026#39;, function(event) { if (event.target.classList.contains(\u0026#39;delete-btn\u0026#39;)) { // 刪除項目 event.target.parentElement.remove(); } }); // 添加新項目 addBtn.addEventListener(\u0026#39;click\u0026#39;, function() { const text = newItemInput.value.trim(); if (text) { const li = document.createElement(\u0026#39;li\u0026#39;); li.innerHTML = ` \u0026lt;span\u0026gt;${text}\u0026lt;/span\u0026gt; \u0026lt;button class=\u0026#34;delete-btn\u0026#34;\u0026gt;刪除\u0026lt;/button\u0026gt; `; todoList.appendChild(li); newItemInput.value = \u0026#39;\u0026#39;; } }); 範例 2：表格操作 \u0026lt;table id=\u0026#34;data-table\u0026#34;\u0026gt; \u0026lt;thead\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;th\u0026gt;姓名\u0026lt;/th\u0026gt; \u0026lt;th\u0026gt;年齡\u0026lt;/th\u0026gt; \u0026lt;th\u0026gt;操作\u0026lt;/th\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;/thead\u0026gt; \u0026lt;tbody\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;td\u0026gt;張三\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;25\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt; \u0026lt;button class=\u0026#34;edit-btn\u0026#34; data-id=\u0026#34;1\u0026#34;\u0026gt;編輯\u0026lt;/button\u0026gt; \u0026lt;button class=\u0026#34;delete-btn\u0026#34; data-id=\u0026#34;1\u0026#34;\u0026gt;刪除\u0026lt;/button\u0026gt; \u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;!-- 更多行... --\u0026gt; \u0026lt;/tbody\u0026gt; \u0026lt;/table\u0026gt; const table = document.getElementById(\u0026#39;data-table\u0026#39;); table.addEventListener(\u0026#39;click\u0026#39;, function(event) { const target = event.target; const id = target.dataset.id; if (target.classList.contains(\u0026#39;edit-btn\u0026#39;)) { console.log(\u0026#39;編輯 ID:\u0026#39;, id); // 執行編輯邏輯 } else if (target.classList.contains(\u0026#39;delete-btn\u0026#39;)) { console.log(\u0026#39;刪除 ID:\u0026#39;, id); // 執行刪除邏輯 if (confirm(\u0026#39;確定要刪除嗎？\u0026#39;)) { target.closest(\u0026#39;tr\u0026#39;).remove(); } } }); 事件代理的注意事項 事件類型限制：只能用於支援冒泡的事件（如 click、keydown 等） 目標元素檢查：需要檢查 event.target 是否為預期的元素 阻止冒泡：如果在子元素中使用 event.stopPropagation()，事件不會冒泡到父元素 進階技巧 使用 matches() 方法 list.addEventListener(\u0026#39;click\u0026#39;, function(event) { if (event.target.matches(\u0026#39;li.item\u0026#39;)) { // 處理符合選擇器的元素 console.log(\u0026#39;點擊了項目\u0026#39;); } }); 使用 closest() 方法 list.addEventListener(\u0026#39;click\u0026#39;, function(event) { const item = event.target.closest(\u0026#39;li\u0026#39;); if (item) { // 處理最近的 li 祖先元素 console.log(\u0026#39;點擊了項目:\u0026#39;, item.textContent); } }); 事件代理是一個強大的技術，能夠有效提升網頁性能，特別是在處理大量動態元素時。合理使用事件代理可以讓我們的代碼更加高效和易於維護。\n","permalink":"https://example.com/posts/day20-%E7%80%8F%E8%A6%BD%E5%99%A8-dom-%E5%85%83%E7%B4%A0%E7%9A%84%E4%BA%8B%E4%BB%B6%E4%BB%A3%E7%90%86/","tags":[],"title":"Day20 - 瀏覽器 DOM 元素的事件代理"},{"categories":[{"LinkTitle":"2022 鐵人賽系列","RelPermalink":"/categories/2022-%E9%90%B5%E4%BA%BA%E8%B3%BD%E7%B3%BB%E5%88%97/"}],"content":"上一篇介紹了 Axios 的基本概念，這篇我們來實際練習如何使用 Axios 來進行 HTTP 請求。\n建立 Axios 實例 我們可以建立一個 Axios 實例來設定共用的配置：\nconst api = axios.create({ baseURL: \u0026#39;https://jsonplaceholder.typicode.com\u0026#39;, timeout: 5000, headers: { \u0026#39;Content-Type\u0026#39;: \u0026#39;application/json\u0026#39; } }); 實作範例：用戶管理系統 讓我們建立一個簡單的用戶管理系統來練習各種 HTTP 方法。\nHTML 結構 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;zh-TW\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width, initial-scale=1.0\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Axios 實作練習\u0026lt;/title\u0026gt; \u0026lt;script src=\u0026#34;https://cdn.jsdelivr.net/npm/axios/dist/axios.min.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt; \u0026lt;h1\u0026gt;用戶管理系統\u0026lt;/h1\u0026gt; \u0026lt;!-- 用戶列表 --\u0026gt; \u0026lt;div id=\u0026#34;users\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;!-- 新增用戶表單 --\u0026gt; \u0026lt;form id=\u0026#34;userForm\u0026#34;\u0026gt; \u0026lt;input type=\u0026#34;text\u0026#34; id=\u0026#34;name\u0026#34; placeholder=\u0026#34;姓名\u0026#34; required\u0026gt; \u0026lt;input type=\u0026#34;email\u0026#34; id=\u0026#34;email\u0026#34; placeholder=\u0026#34;Email\u0026#34; required\u0026gt; \u0026lt;button type=\u0026#34;submit\u0026#34;\u0026gt;新增用戶\u0026lt;/button\u0026gt; \u0026lt;/form\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; JavaScript 實作 // 建立 Axios 實例 const api = axios.create({ baseURL: \u0026#39;https://jsonplaceholder.typicode.com\u0026#39;, timeout: 5000 }); // DOM 元素 const usersDiv = document.getElementById(\u0026#39;users\u0026#39;); const userForm = document.getElementById(\u0026#39;userForm\u0026#39;); // 取得所有用戶 async function fetchUsers() { try { const response = await api.get(\u0026#39;/users\u0026#39;); displayUsers(response.data); } catch (error) { console.error(\u0026#39;取得用戶資料失敗:\u0026#39;, error); alert(\u0026#39;取得用戶資料失敗\u0026#39;); } } // 顯示用戶列表 function displayUsers(users) { usersDiv.innerHTML = users.map(user =\u0026gt; ` \u0026lt;div class=\u0026#34;user-card\u0026#34;\u0026gt; \u0026lt;h3\u0026gt;${user.name}\u0026lt;/h3\u0026gt; \u0026lt;p\u0026gt;Email: ${user.email}\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;電話: ${user.phone}\u0026lt;/p\u0026gt; \u0026lt;button onclick=\u0026#34;editUser(${user.id})\u0026#34;\u0026gt;編輯\u0026lt;/button\u0026gt; \u0026lt;button onclick=\u0026#34;deleteUser(${user.id})\u0026#34;\u0026gt;刪除\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; `).join(\u0026#39;\u0026#39;); } // 新增用戶 async function createUser(userData) { try { const response = await api.post(\u0026#39;/users\u0026#39;, userData); console.log(\u0026#39;用戶新增成功:\u0026#39;, response.data); alert(\u0026#39;用戶新增成功\u0026#39;); fetchUsers(); // 重新載入用戶列表 } catch (error) { console.error(\u0026#39;新增用戶失敗:\u0026#39;, error); alert(\u0026#39;新增用戶失敗\u0026#39;); } } // 更新用戶 async function updateUser(id, userData) { try { const response = await api.put(`/users/${id}`, userData); console.log(\u0026#39;用戶更新成功:\u0026#39;, response.data); alert(\u0026#39;用戶更新成功\u0026#39;); fetchUsers(); // 重新載入用戶列表 } catch (error) { console.error(\u0026#39;更新用戶失敗:\u0026#39;, error); alert(\u0026#39;更新用戶失敗\u0026#39;); } } // 刪除用戶 async function deleteUser(id) { if (!confirm(\u0026#39;確定要刪除這個用戶嗎？\u0026#39;)) return; try { await api.delete(`/users/${id}`); console.log(\u0026#39;用戶刪除成功\u0026#39;); alert(\u0026#39;用戶刪除成功\u0026#39;); fetchUsers(); // 重新載入用戶列表 } catch (error) { console.error(\u0026#39;刪除用戶失敗:\u0026#39;, error); alert(\u0026#39;刪除用戶失敗\u0026#39;); } } // 表單提交事件 userForm.addEventListener(\u0026#39;submit\u0026#39;, (e) =\u0026gt; { e.preventDefault(); const name = document.getElementById(\u0026#39;name\u0026#39;).value; const email = document.getElementById(\u0026#39;email\u0026#39;).value; createUser({ name, email }); // 清空表單 userForm.reset(); }); // 頁面載入時取得用戶資料 document.addEventListener(\u0026#39;DOMContentLoaded\u0026#39;, fetchUsers); 進階功能 請求攔截器 // 請求攔截器 - 在每個請求發送前執行 api.interceptors.request.use( config =\u0026gt; { console.log(\u0026#39;發送請求:\u0026#39;, config); // 可以在這裡添加認證 token // config.headers.Authorization = `Bearer ${token}`; return config; }, error =\u0026gt; { return Promise.reject(error); } ); 回應攔截器 // 回應攔截器 - 在每個回應接收後執行 api.interceptors.response.use( response =\u0026gt; { console.log(\u0026#39;收到回應:\u0026#39;, response); return response; }, error =\u0026gt; { if (error.response?.status === 401) { // 處理認證失敗 alert(\u0026#39;認證失敗，請重新登入\u0026#39;); } return Promise.reject(error); } ); 取消請求 let cancelToken; async function fetchUsersWithCancel() { // 如果之前有請求正在進行，先取消它 if (cancelToken) { cancelToken.cancel(\u0026#39;取消之前的請求\u0026#39;); } // 建立新的取消令牌 cancelToken = axios.CancelToken.source(); try { const response = await api.get(\u0026#39;/users\u0026#39;, { cancelToken: cancelToken.token }); displayUsers(response.data); } catch (error) { if (axios.isCancel(error)) { console.log(\u0026#39;請求已取消\u0026#39;); } else { console.error(\u0026#39;請求失敗:\u0026#39;, error); } } } 錯誤處理最佳實務 async function handleRequest() { try { const response = await api.get(\u0026#39;/users\u0026#39;); return response.data; } catch (error) { if (error.response) { // 伺服器回應了錯誤狀態碼 console.error(\u0026#39;回應錯誤:\u0026#39;, error.response.status, error.response.data); } else if (error.request) { // 請求已發出但沒有收到回應 console.error(\u0026#39;網路錯誤:\u0026#39;, error.request); } else { // 其他錯誤 console.error(\u0026#39;錯誤:\u0026#39;, error.message); } throw error; } } ","permalink":"https://example.com/posts/day19-axios-%E5%AF%A6%E4%BD%9C/","tags":[],"title":"Day19 - Axios 實作"},{"categories":[{"LinkTitle":"2022 鐵人賽系列","RelPermalink":"/categories/2022-%E9%90%B5%E4%BA%BA%E8%B3%BD%E7%B3%BB%E5%88%97/"}],"content":"在現代網頁開發中，我們經常需要在不重新載入整個頁面的情況下，與伺服器進行資料交換。這就需要用到 AJAX 技術。\n什麼是 AJAX AJAX 的全名是 Asynchronous JavaScript and XML，中文翻譯為「非同步 JavaScript 和 XML」。雖然名稱中包含 XML，但現在更常使用 JSON 格式來傳輸資料。\nAJAX 的主要特色：\n非同步處理：不會阻塞使用者介面 部分更新：只更新頁面的特定部分 提升用戶體驗：避免整個頁面重新載入 傳統的 AJAX 方法 XMLHttpRequest const xhr = new XMLHttpRequest(); xhr.open(\u0026#39;GET\u0026#39;, \u0026#39;https://api.example.com/users\u0026#39;); xhr.onreadystatechange = function() { if (xhr.readyState === 4 \u0026amp;\u0026amp; xhr.status === 200) { const data = JSON.parse(xhr.responseText); console.log(data); } }; xhr.send(); Fetch API fetch(\u0026#39;https://api.example.com/users\u0026#39;) .then(response =\u0026gt; response.json()) .then(data =\u0026gt; console.log(data)) .catch(error =\u0026gt; console.error(\u0026#39;Error:\u0026#39;, error)); 什麼是 Axios Axios 是一個基於 Promise 的 HTTP 客戶端，可以用於瀏覽器和 Node.js。它提供了比原生 fetch API 更多的功能和更好的瀏覽器相容性。\nAxios 的優點 Promise 支援：使用 Promise 讓非同步程式碼更易讀 請求和回應攔截器：可以在發送請求前或接收回應後進行處理 自動 JSON 轉換：自動將回應轉換為 JSON 格式 錯誤處理：更完善的錯誤處理機制 取消請求：支援取消正在進行的請求 瀏覽器相容性：支援較舊的瀏覽器 Axios 基本使用方法 安裝 Axios # 使用 npm npm install axios # 使用 CDN \u0026lt;script src=\u0026#34;https://cdn.jsdelivr.net/npm/axios/dist/axios.min.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; GET 請求 axios.get(\u0026#39;https://api.example.com/users\u0026#39;) .then(response =\u0026gt; { console.log(response.data); }) .catch(error =\u0026gt; { console.error(\u0026#39;Error:\u0026#39;, error); }); POST 請求 axios.post(\u0026#39;https://api.example.com/users\u0026#39;, { name: \u0026#39;John Doe\u0026#39;, email: \u0026#39;john@example.com\u0026#39; }) .then(response =\u0026gt; { console.log(response.data); }) .catch(error =\u0026gt; { console.error(\u0026#39;Error:\u0026#39;, error); }); 使用 async/await async function fetchUsers() { try { const response = await axios.get(\u0026#39;https://api.example.com/users\u0026#39;); console.log(response.data); } catch (error) { console.error(\u0026#39;Error:\u0026#39;, error); } } Axios vs Fetch API 特性 Axios Fetch API Promise 支援 ✅ ✅ JSON 自動轉換 ✅ ❌（需手動轉換） 錯誤處理 ✅ ❌（需手動檢查） 請求攔截器 ✅ ❌ 回應攔截器 ✅ ❌ 取消請求 ✅ ✅ 瀏覽器支援 更好 IE 不支援 ","permalink":"https://example.com/posts/day18-ajax-axios-%E4%BB%8B%E7%B4%B9/","tags":[],"title":"Day18 - AJAX \u0026 Axios 介紹"},{"categories":[{"LinkTitle":"2022 鐵人賽系列","RelPermalink":"/categories/2022-%E9%90%B5%E4%BA%BA%E8%B3%BD%E7%B3%BB%E5%88%97/"}],"content":"在開發 API 時，我們需要一個工具來測試 API 是否正常運作，Postman 就是一個非常好用的 API 測試工具。\n什麼是 Postman Postman 是一個 API 開發環境，它提供了一個直觀的介面來建立、測試、記錄和監控 API。無論是 REST API、GraphQL API 或是其他類型的 API，Postman 都能夠幫助開發者進行測試。\nPostman 的主要功能 API 測試：可以發送各種 HTTP 請求（GET、POST、PUT、DELETE 等） 環境變數：可以設定不同環境的變數，方便切換測試環境 集合管理：可以將相關的 API 請求組織成集合 測試腳本：可以撰寫測試腳本來驗證 API 回應 文件生成：可以自動生成 API 文件 如何使用 Postman 1. 下載安裝 前往 Postman 官網下載並安裝應用程式，或是使用網頁版。\n2. 發送請求 選擇 HTTP 方法（GET、POST 等） 輸入 API 網址 設定 Headers（如果需要） 設定 Body（針對 POST、PUT 請求） 點擊 Send 發送請求 3. 查看回應 發送請求後，Postman 會顯示：\n回應狀態碼 回應時間 回應大小 回應內容（JSON、HTML、XML 等格式） Postman 的進階功能 環境變數 可以設定不同的環境變數，例如：\n開發環境：{{base_url}} = http://localhost:3000 測試環境：{{base_url}} = https://test-api.example.com 生產環境：{{base_url}} = https://api.example.com 測試腳本 可以在 Tests 標籤中撰寫 JavaScript 程式碼來測試 API 回應：\n// 測試狀態碼是否為 200 pm.test(\u0026#34;Status code is 200\u0026#34;, function () { pm.response.to.have.status(200); }); // 測試回應時間是否小於 1000ms pm.test(\u0026#34;Response time is less than 1000ms\u0026#34;, function () { pm.expect(pm.response.responseTime).to.be.below(1000); }); // 測試回應內容 pm.test(\u0026#34;Response contains user data\u0026#34;, function () { const jsonData = pm.response.json(); pm.expect(jsonData).to.have.property(\u0026#39;name\u0026#39;); }); 為什麼要使用 Postman 方便測試：不需要寫程式碼就能測試 API 團隊協作：可以分享集合給團隊成員 自動化測試：可以設定自動化測試流程 文件產生：可以自動產生 API 文件 跨平台：支援 Windows、macOS、Linux ","permalink":"https://example.com/posts/day17-postman/","tags":[],"title":"Day17 - Postman"},{"categories":[{"LinkTitle":"2022 鐵人賽系列","RelPermalink":"/categories/2022-%E9%90%B5%E4%BA%BA%E8%B3%BD%E7%B3%BB%E5%88%97/"}],"content":"API 的全名是 Application Programming Interface，中文翻譯為「應用程式介面」，簡單來說就是一個介面，讓不同的程式可以互相溝通。\n而 RESTful API 是一種 API 的設計風格，REST 的全名是 Representational State Transfer，中文翻譯為「具象狀態轉移」。\nRESTful API 的特色 無狀態性 (Stateless)：每個請求都應該包含處理該請求所需的所有資訊，伺服器不會儲存任何客戶端的狀態資訊。\n統一介面 (Uniform Interface)：所有的資源都透過相同的介面進行操作，主要包含：\n資源識別：透過 URI 來識別資源 資源操作：透過 HTTP 方法來操作資源 自我描述的訊息：每個訊息都包含如何處理該訊息的足夠資訊 超媒體作為應用程式狀態的引擎 客戶端-伺服器架構 (Client-Server)：將使用者介面與資料儲存分離，提高了系統的可移植性。\nHTTP 方法與 CRUD 操作的對應 HTTP 方法 CRUD 操作 說明 GET Read 取得資源 POST Create 建立資源 PUT Update 更新整個資源 PATCH Update 部分更新資源 DELETE Delete 刪除資源 RESTful API 的 URL 設計原則 使用名詞而非動詞\n好：GET /users/123 壞：GET /getUser/123 使用複數名詞\n好：GET /users 壞：GET /user 使用階層結構表示資源關係\nGET /users/123/posts - 取得用戶 123 的所有文章 GET /users/123/posts/456 - 取得用戶 123 的文章 456 使用查詢參數進行過濾、排序和分頁\nGET /users?age=25\u0026amp;sort=name\u0026amp;page=2 HTTP 狀態碼 RESTful API 應該回傳適當的 HTTP 狀態碼：\n2xx 成功\n200 OK：請求成功 201 Created：資源已建立 204 No Content：請求成功但沒有回傳內容 4xx 客戶端錯誤\n400 Bad Request：請求格式錯誤 401 Unauthorized：未授權 404 Not Found：資源不存在 5xx 伺服器錯誤\n500 Internal Server Error：伺服器內部錯誤 ","permalink":"https://example.com/posts/day16-restful-api/","tags":[],"title":"Day16 - RESTful API"},{"categories":[{"LinkTitle":"2022 鐵人賽系列","RelPermalink":"/categories/2022-%E9%90%B5%E4%BA%BA%E8%B3%BD%E7%B3%BB%E5%88%97/"}],"content":"上一篇介紹了 Cookie，Cookie 雖然方便，但只能存放 4KB 的資料，除了 Cookie，還有其他的方法可以讓資料存在本地端嗎？\n答案是可以的！透過 HTML5 所提供的 Web Storage，我們可以在本地端儲存更多的資料。\nWeb Storage Web Storage 可分為兩種：Local Storage 和 Session Storage\nLocal Storage 沒有過期時間，除非手動刪除，不然資料會一直在 儲存容量比 Cookie 大，約為 5MB 左右 只能在同源的頁面中存取，符合同源政策 只能儲存字串 Session Storage 頁面關閉時資料就會消失 儲存容量比 Cookie 大，約為 5MB 左右 只能在同一個分頁中存取 只能儲存字串 Local Storage 使用方式 // 設置資料 localStorage.setItem(\u0026#39;key\u0026#39;, \u0026#39;value\u0026#39;); // 取得資料 localStorage.getItem(\u0026#39;key\u0026#39;); // 刪除特定資料 localStorage.removeItem(\u0026#39;key\u0026#39;); // 清除所有資料 localStorage.clear(); Session Storage 使用方式 // 設置資料 sessionStorage.setItem(\u0026#39;key\u0026#39;, \u0026#39;value\u0026#39;); // 取得資料 sessionStorage.getItem(\u0026#39;key\u0026#39;); // 刪除特定資料 sessionStorage.removeItem(\u0026#39;key\u0026#39;); // 清除所有資料 sessionStorage.clear(); 比較表 特性 Cookie Local Storage Session Storage 儲存容量 4KB 5MB 5MB 過期時間 可設定 永久 分頁關閉 與伺服器通訊 會自動發送 不會 不會 存取範圍 同源 同源 同分頁 ","permalink":"https://example.com/posts/day15-web-storage/","tags":[],"title":"Day15 - Web Storage"},{"categories":[{"LinkTitle":"2022 鐵人賽系列","RelPermalink":"/categories/2022-%E9%90%B5%E4%BA%BA%E8%B3%BD%E7%B3%BB%E5%88%97/"}],"content":" 當我們在 Stackoverflow 上尋找為什麼會出現某個 bug 時，常常會在網站的左下角看到一個視窗，要你點選「同意所有 cookies」 cookie 究竟代表的是什麼意思呢？\nCookie 簡單來說，cookie 會儲存你之前在這個網站所做過的動作，並存在記憶體中，由於 HTTP 是無狀態的(Stateless)，也就是說伺服器不會記得使用者前面做過了什麼事，所以只要你關閉網站或是跳頁，伺服器就不會認得使用者之前所做過的動作。在登入時，常常會看到已經幫我們自動填入帳號密碼，那也是因為有了 cookie 的功勞！\nCookie 依照儲存位置可分為「記憶體 Cookie」和「硬碟 Cookie」\n記憶體 Cookie 由瀏覽器管理，存在記憶體中 瀏覽器關閉，資料就會消失 儲存時間較短暫 硬碟 Cookie 存在硬碟中 有有效期限，時間到了或是使用者手動清理，Cookie 就會被清除 儲存時間較長 如何檢視 Cookie 的資料 打開 Chrome 瀏覽器，點選右上角的三個點點\u0026gt;「設定」\u0026gt;「隱私性和安全性」\u0026gt;「Cookie 和其他網站資料」\u0026gt;「顯示所有 Cookie 和網站資料」，就能看到瀏覽器中的所有網站的 Cookie 和裡面的資料了！\nCookie 的限制 你想說有 Cookie 這麼方便的東西，我們還需要別的東西嗎？ 需要，因為下面的這些限制，我們還有 Local Storage 和 Session Storage，至於這兩個是什麼會在下一篇介紹\n一個 Cookie 最多只能儲存 4KB 的資料 客戶端可以儲存的 Cookie 最大數量是 300 個，若超過會自動刪除多出來的 ","permalink":"https://example.com/posts/day14-cookie/","tags":[],"title":"Day14 - Cookie"},{"categories":[{"LinkTitle":"2022 鐵人賽系列","RelPermalink":"/categories/2022-%E9%90%B5%E4%BA%BA%E8%B3%BD%E7%B3%BB%E5%88%97/"}],"content":"相信有進行過網站開發，特別是後端開發的人，對下面的錯誤訊息應該不陌生：\nrequest has been blocked by CORS policy: No \u0026#39;Access-Control-Allow-Origin\u0026#39; header is present on the requested resource. 這篇就來談談為什麼 CORS 政策會出現的原因！CORS 的全名是「Cross-Origin Resource Sharing」，中文翻譯為「跨來源資源共用」。\n這是什麼意思呢？ 一般來說，如果是向同源的伺服器抓取資料，是可以正常執行的。但如果瀏覽器偵測到你試圖抓取非同源的 request，就會因為違反同源政策而被阻擋。若是這些跨來源的 AJAX 沒有限制的話，就可以透過使用者的瀏覽器，拿到「任意網站」的內容，包含了各種可能有敏感資訊的網站。\n為什麼需要有這個機制呢？ 很多公司都會有自己的內部網站，假設有駭客知道了這個內部網站的網址，然後在網頁上寫一段 AJAX 去抓取他的資料，這樣駭客就有可能有辦法抓取網站內容！\n同源是什麼意思呢？ 同源需要包含以下三個條件：\n相同的通訊協定(protocol) http://bernice.tw和https://bernice.tw不同源 相同的網域(domain) https://bernice.tw和https://subdomain.bernice.tw不同源 相同的埠號(port) https://bernice.tw和https://bernice.tw:8000不同源 https://bernice.tw/a.html和https://bernice.tw/b.html是同源的！\n同源政策出現時該怎麼解決呢？ 關掉瀏覽器的安全性設置 把 fetch mode 設成 no-cors 不要用 AJAX 拿資料 參考來源：\nhttps://blog.huli.tw/2021/02/19/cors-guide-1/\r","permalink":"https://example.com/posts/day13-cors-%E5%90%8C%E6%BA%90%E6%94%BF%E7%AD%96/","tags":[],"title":"Day13 - CORS 同源政策"},{"categories":[{"LinkTitle":"2022 鐵人賽系列","RelPermalink":"/categories/2022-%E9%90%B5%E4%BA%BA%E8%B3%BD%E7%B3%BB%E5%88%97/"}],"content":"在瀏覽器打開任何一個網頁，在 Windows 系統按下鍵盤中的 F12，如果是 macOS 系統則按下 fn + F12，或是按下滑鼠右鍵選擇「檢查」，就能打開 Chrome Developer Tool，也就是我們俗稱的 Dev Tool。\n其實每個瀏覽器都有這樣子的工具，在這個範例中以 Chrome 做說明\n那這個工具有哪些功能呢？以下介紹幾個較常用的功能：\n1. 元素(Elements)：顯示網頁中的 DOM 元素以及 Style css 屬性 這在前端開發中是個蠻容易使用到的工具，它可以方便我們判別每個元素在畫面中的位置以及該元素的各種屬性\n如果想看到網頁中某個元素的 DOM 在哪裡，可以點選左上角的按鈕，將滑鼠拖曳到想查看的元素，就能夠看到該元素的相關屬性\n2. 主控台(Console)：執行 javascript 程式碼、查看網頁狀態、log messeges 在畫面載入時若有錯誤訊息可以在這裡查看\n最底下的欄位可以執行 javascript 程式碼，在網頁開發中如果在 js 檔有寫到 console.log 也可以在這裡查看輸出結果(我一般是拿來 debug 用)\n另外，在左上角可以看到這樣的按鈕，可以將 console 先前的紀錄清除\n3. 網路(Network)：查看網頁所接收到的所有 Request 和 Response 封包 可以看到左下角有顯示幾項要求，代表發出了多少 Request\n接著，點選其中一個 Request，就能看到該請求的相關資訊\n其實網頁上所顯示的不管是圖片、文字，都是由一個個封包所組成的，在我們打開網頁時，就已經在向伺服器發出 Request。伺服器回傳了許多的 Response，組合出了我們所看到的畫面。\n","permalink":"https://example.com/posts/day12-chrome-developer-tool/","tags":[],"title":"Day12 - Chrome Developer Tool"},{"categories":[{"LinkTitle":"2022 鐵人賽系列","RelPermalink":"/categories/2022-%E9%90%B5%E4%BA%BA%E8%B3%BD%E7%B3%BB%E5%88%97/"}],"content":"HTTP Request 根據網頁開發的需求，會有不同的種類，以下介紹幾個常見的 Request Method\nGET：取得資料 傳遞的參數會顯示在 URL 上 因為是抓取資料為主，所以不會使資料有所更動 不需要傳遞參數給伺服器 範例：取得頁面、資料 POST：提交資料 傳遞的參數會存在 Messege Body 中，不會顯示在 URL 上，和 GET 比相對安全 需要傳遞參數，因此抓取有條件的資料也可以使用 POST 範例：送出表單 PATCH：更新部分資料 更換資源部分內容 範例：只會改變表單中的其中一個欄位 PUT：取代全部資源 取代整個資源 範例：會更新表單中的所有欄位 DELETE：刪除資料 刪除指定資源 範例：依照 ID 刪除某項資料 OPTION： 問這個資源應該要怎麼獲取，常在發送 CORS 的預檢請求時使用，不過這個比較少看到 CONNECT： 和指定資源標明的伺服器之間，建立隧道（tunnel） TRACE： 會與指定資源標明的伺服器之間，執行迴路返回測試（loop-back test） 這篇大概對一些常見的 Request Method 做了一些介紹，下一篇就要來介紹如何使用這些方法。\n","permalink":"https://example.com/posts/day11-http-request-method/","tags":[],"title":"Day11 - HTTP Request Method"},{"categories":[{"LinkTitle":"2022 鐵人賽系列","RelPermalink":"/categories/2022-%E9%90%B5%E4%BA%BA%E8%B3%BD%E7%B3%BB%E5%88%97/"}],"content":"當我們送出 HTTP Request，就會收到由伺服器傳回的 HTTP Response，但每個 Response 可能會被很多因素阻礙，導致無法正常的傳回客戶端，而狀態碼的存在就是為了清楚顯示每個 Response 處於什麼狀態。\n像是我們常見到的 404，代表的就是目前這個頁面不存在\n每個狀態碼大部分由三個數字所組成，從最左邊的數字就可以看出狀態碼是哪一類。狀態碼全部可分為下面五大類：\n類型 意義 1xx 訊息 2xx 成功 3xx 重新導向 4xx 客戶端錯誤 5xx 伺服器錯誤 下面是每個分類的狀態碼：\n1xx 100 繼續執行先前所發出的請求 101 切換通訊協定 2xx 200 客戶端請求成功 201 已建立 202 已接受 203 非授權資訊 204 沒有內容 205 重設內容 206 部分內容 207 傳回的訊息會是 XML 型態 208 響應已傳送 226 已完成響應 3xx 300 請求被收到了，但是需要重新定向 301 被請求的資源永久移動到新位置 302 臨時重新導向 303 當前請求的回應可以在另一個 URI 上被找到 304 已讀取過的圖片或網頁，由瀏覽器 Cache 中讀取 305 被請求的資源需要通過指定的代理才能被存取 307 請求與另一個 URI 重複，但後續的請求應仍使用原始的 URI 308 請求和所有將來的請求應該使用另一個 URI 重複 4xx 400 客戶端發生錯誤 401 沒有認證 403 伺服器已經理解請求，但是拒絕執行它 404 請求失敗 405 請求方法錯誤 406 請求的資源的內容特性無法滿足請求頭中的條件 407 要求 Proxy 認證 408 Request Timeout 409 因為請求存在衝突無法處理該請求 410 請求的資源不再可用 411 Header 需要定義訊息長度 5xx 500 執行錯誤 501 請求方法不支持 502 無效的閘道 503 服務無法使用 504 閘道逾時 505 HTTP 版本不支持 506 伺服器存在內部組態錯誤 507 伺服器無法儲存請求 508 無限迴圈 510 獲取資源策略無法被滿足 511 客戶端需要進行身分驗證 ","permalink":"https://example.com/posts/day10-http-%E7%8B%80%E6%85%8B%E7%A2%BC/","tags":[],"title":"Day10 - HTTP 狀態碼"},{"categories":[{"LinkTitle":"2022 鐵人賽系列","RelPermalink":"/categories/2022-%E9%90%B5%E4%BA%BA%E8%B3%BD%E7%B3%BB%E5%88%97/"}],"content":"URL 的全名是 Uniform Resource Locator，翻成中文的話就是「統一資源定位符」，也就是我們俗稱的網址，它就像是網路上的門牌號碼，可以根據網址去找到我們想要的網路資源，不管是網頁、圖片、影音、網址，網址都和這些資源緊密連結。\nURL 可以拆開成以下幾個部分：\n通訊協定(protocol)：常見的有 http 和 https，後面會跟著「://」，也就是層級 URL 標記符號\n網域(domain)：分為三個部分，中間以「.」進行區隔，三個部分分別是子網域、網域名稱、TLD(頂級網域名稱)\n埠號(port)：一般來說，在打網址時不需要特別打出來(http 的常用埠號是 80、https 是 443)\n資源路徑(path)：資源的取得路徑\n參數(parameter)：GET 模式的表單參數，其實就是 query，在網站中進行換頁時，可以透過 query 將參數帶到下個頁面，以「?」為起點，後面接著的分別是參數的 key 和 value，中間以「=」隔開\n錨點(anchor)：簡單來說，寫在「#」後面的字串會對應到網頁中的 DOM 元素中的 id，像是如果在 URL 後面加上#section-name，網址就會導到\u0026lt;div id=\u0026quot;section-name\u0026quot;\u0026gt;的地方，在「#」後面的部分是不會被傳送到 server 的。\n參考來源：\nhttps://stackoverflow.com/questions/12096614/how-to-use-an-html-anchor-in-a-dynamic-url\r","permalink":"https://example.com/posts/day8-url-%E7%9A%84%E7%B5%84%E6%88%90/","tags":[],"title":"Day8 - URL 的組成"},{"categories":[{"LinkTitle":"2022 鐵人賽系列","RelPermalink":"/categories/2022-%E9%90%B5%E4%BA%BA%E8%B3%BD%E7%B3%BB%E5%88%97/"}],"content":"平常我們在使用瀏覽器時，都可以看到上方輸入網址的地方有個鎖頭，這代表我們現在在瀏覽時向伺服器傳送的資料正受到保護，但背後究竟是什麼原理呢？\n這就要先來談談 HTTP 是什麼樣的協定了～\nHTTP(超文本傳輸協定) 是一種被設計成用來讓瀏覽器和伺服器溝通的網路協定，使用 TCP 進行傳輸，但在這傳輸的過程中因為沒有任何加密的手續，封包中的資料皆是明文，因此如果有人在傳輸過程中惡意監聽，個資就有可能被偷竊，甚至是盜用。\n因此就出現了 HTTPS 這個相對安全的協定！\nHTTPS(超文本傳輸安全協定, S=Secure) 顧名思義，HTTPS 比起 HTTP 更加安全，雖然 HTTP 和 HTTPS 在本質上是相同的，但 HTTPS 多使用了 SSL/TLS(安全通訊端階層憑證)去加密封包，藉此保護在傳輸過程中的封包不會被惡意攻擊，達到了隱私性和安全性。\n但由於因 HTTP 所造成的攻擊實在太多，從 2019 年 12 月開始，Chrome79 開始逐步封鎖 HTTPS 網頁中，以 HTTP 下載的內容。\n參考來源：\nhttps://tw.alphacamp.co/blog/http-https-difference\r","permalink":"https://example.com/posts/day9-http/https/","tags":[],"title":"Day9 - HTTP/HTTPS"},{"categories":[{"LinkTitle":"2022 鐵人賽系列","RelPermalink":"/categories/2022-%E9%90%B5%E4%BA%BA%E8%B3%BD%E7%B3%BB%E5%88%97/"}],"content":" 網際網路就像是車水馬龍的道路，而世界各地的電腦就像是一棟棟房子，網際網路上所建構的道路可以連接每台電腦，讓每個裝置可以進行溝通與交換資料。\nIP 如果把網路比喻成道路，那 IP 就像是每台電腦的門牌號碼，每個連接到網際網路的裝置都必須要有其對應的 IP，資料需要有正確的「門牌號碼」才能順利地傳送資料。\nIP 依照長度可分為 IPv4(32 bits) 和 IPv6(128 bits)，早期都是使用 IPv4 定址，但因為 IPv4 位址在 2011 年沒有辦法再分配給新裝置 IPv4 位址後，產生了 IPv6 這種新的位址格式，可以提供更多的 IP 位址。\n關於 IPv4 和 IPv6 的更多內容將會在之後的篇章介紹！\nDNS(Domain Name System) DNS 是一個將網域名稱和 IP 位址做對應的資料庫，而網域名稱(Domain Name)就是我們平常在瀏覽器上方的網址列所看到的一長串由 http 或 https 開頭的字串，像是https://www.google.com、https://www.ithome.com.tw\n當我們網站的網域名稱後，電腦就會開始尋找那個網站的 IP 位址，這樣使用者就不需要記憶一長串數字的 IP 了！\n","permalink":"https://example.com/posts/day7-dns-%E5%92%8C-ip-%E7%9A%84%E9%97%9C%E4%BF%82/","tags":[],"title":"Day7 - DNS 和 IP 的關係"},{"categories":[{"LinkTitle":"2022 鐵人賽系列","RelPermalink":"/categories/2022-%E9%90%B5%E4%BA%BA%E8%B3%BD%E7%B3%BB%E5%88%97/"}],"content":"MAC 位址(Media Access Control Address)，中文翻譯為「媒體存取控制位址」，其實就是乙太網路位址(Ethernet Address)，是由 OSI 模型中第二層的資料連結層所負責的地址，共 48 位元，以十六進位表示。\n每張網路卡在生產時都會被賦予一個唯一的 MAC 位址，就像是網路卡的身分證號碼一樣，他被用來確認網路裝置位置的位址，所以在連接網卡時需要確認好 MAC 位址。\n如何查看自己的 MAC 位址 ifconfig這個指令是 UNIX 系統用來查看網路參數的指令，可以觀察所有的網路介面\n$ ifconfig 在終端機輸入這個指令後，就會看到一長串的輸出，下面會列出目前已經被啟動的網路卡\n也可以在指令後面加上要列出第幾張網路卡的參數，像是en0代表第一張網路卡\n$ ifconfig \u0026lt;網路卡參數\u0026gt; 結果就會看到下圖的輸出：\n其中ether f8:ff:c2:52:9f:3c指的就是 MAC 位址，inet 那行代表的是 ipv4 的位址，inet6 則是代表 ipv6 的位址\n如何修改自己的 MAC 位址 記得要在指令最前面加sudo，ifconfig後面要接上要更改的網路卡號碼和新的位址。\n$ sudo ifconfig en0 ether XX:XX:XX:XX:XX:XX 參考來源：\nhttps://linux.vbird.org/linux_server/centos6/0140networkcommand.php#ifconfig\r","permalink":"https://example.com/posts/day6-mac-%E5%9C%B0%E5%9D%80/","tags":[],"title":"Day6 - MAC 地址"},{"categories":[{"LinkTitle":"2022 鐵人賽系列","RelPermalink":"/categories/2022-%E9%90%B5%E4%BA%BA%E8%B3%BD%E7%B3%BB%E5%88%97/"}],"content":" 這篇主要會介紹 IPV4 \u0026amp; IPV6 的歷史，以及介紹這兩種位址的表示方式的主要差異。\n網路上很常看到流傳著 IPV4 即將用盡的消息，但 IPV4 可以提供的位址數量有2的32次方這麼多個位址，換算下來其實大約有 42 億個位址，為什麼明明就有這麼多位址，卻說 IPV4 即將用盡了呢？\n由於一些位址是為了特殊用途而保留的，如專用網路(約 1800 萬個位址)和多播位址(約 2.7 億個位址)，隨著位址不斷被分配給終端使用者，IPv4 位址枯竭問題也隨之產生，除非老會員歸還位址，否則很難再分配給新會員位址。\n因此 IPV6 就誕生了！ IPV6 因為一組位址由 128 位元所呈現，因此能比 IPV4 提供好幾億倍的位址。\n位址的表示方式 IPV4 位址總共有 32 位元，每 8 個位元就會被「.」隔開，一共 4 組，使用二進位表示，所以看起來會像是下面這樣\n而 IPV6 則是有 128 位元，每 16 個位元就會被「:」隔開，一共 8 組，但因為他是用十六進位表示，所以每個被「:」隔開的一組其實有 16 個位元\n參考來源：\nhttps://zh.wikipedia.org/zh-tw/IPv4\rhttps://zh.wikipedia.org/wiki/IPv4%E4%BD%8D%E5%9D%80%E6%9E%AF%E7%AB%AD\r","permalink":"https://example.com/posts/day5-ipv4-ipv6/","tags":[],"title":"Day5 - IPV4 \u0026 IPV6"},{"categories":[{"LinkTitle":"2022 鐵人賽系列","RelPermalink":"/categories/2022-%E9%90%B5%E4%BA%BA%E8%B3%BD%E7%B3%BB%E5%88%97/"}],"content":"TCP、UDP 是什麼？ 這兩種都是常見的網路協定，雖然同樣都是傳送資料，但在性質上卻有很大的不同。\nTCP(傳輸控制協定): 為了保證不會有封包遺失的狀況發生，每個封包會分配到一個唯一的識別碼和序號，也就是下圖的 Sequence number，可以讓接收端識別封包的順序和完整性，和 UDP 相比較為可靠。\n那 TCP 是怎麼確認封包是否真的傳送到對方手中的呢？有個 Double check 的機制，也就是「三方交握(Three Way Handshake)」。\nSYN(synchronous):同步封包 ACK(ACKnowledgement):確認\n步驟：\nClient 發出一個同步封包，向 Server 請求連線，這時還沒有傳送任何實際要傳送的資料。 此時 Server 接收到 Client 的請求後，知道 Client 有傳送資料的請求，就回傳一個 OK 的訊息給 Client，說他可以接收訊息了！ 確認 Server 可以接收資料後，Client 便把傳送的是實際要傳送的資料 常見的應用如下：\n郵件傳輸 文字訊息 UDP(使用者資料包協定): UDP 沒有三方交握的機制，缺乏可靠性和卻也因此能比 TCP 以更快的速度傳送資料，\n常見的應用如下：\n線上遊戲 影片串流 封包的架構 以下介紹 TCP 和 UDP 的封包結構，下面兩張圖看起來是一個表，但實際在傳送時是以一長條的 bits 去傳遞的。\nTCP 封包 UDP 封包 ","permalink":"https://example.com/posts/day4-tcp/udp/","tags":[],"title":"Day4 - TCP/UDP"},{"categories":[{"LinkTitle":"2022 鐵人賽系列","RelPermalink":"/categories/2022-%E9%90%B5%E4%BA%BA%E8%B3%BD%E7%B3%BB%E5%88%97/"}],"content":"今天介紹兩種常用在連接遠端電腦的通訊協定\nTelnet 是一種應用層協定，因為是明文傳輸，沒有加密的流程，可能會有竊聽的問題，由於安全問題，很多伺服器都會封鎖 Telnet 服務，防火牆在預設情况下是不信任 Telnet 的。\n應用：登入香港公共圖書館的資料查詢系統、大部份的電信裝置提供 Telnet 及 SSH 介面讓管理者連入進行設定及維護。\n但因為 Telnet 的不安全性，因此之後出現了相對安全的 SSH\nSSH(Secure Shell，安全外殼協定) 是一種加密的連線機制，由 IETF 的網路工作小組（Network Working Group）所制定，由傳輸層協定、用戶認證協定、連接協定三種協定所組成，和 Telnet 只差在多了一道加密的手續，所以也可以把它想像成是加密過的 Telnet，在傳送資料時較不會有被竊聽的問題。 因為 SSH 採用的是非對稱金鑰加密，所以只有「被認可的人」才能夠解密訊息。SSH 可以透過帳密和金鑰兩種方式進行安全驗證，就算是在一個不安全的網絡裡面，SSH 都能夠確保連線不被竊聽。\n應用：PuTTY、WinSCP、Konqueror、SSH 客戶端、隧道協定\n比較 SSH Telnet 安全性 較安全 較不安全 金鑰 有(非對稱加密) 無 參考來源：\nhttps://zh.wikipedia.org/zh-mo/Secure_Shell\r","permalink":"https://example.com/posts/day3-ssh/telnet/","tags":[],"title":"Day3 - SSH/Telnet"},{"categories":[{"LinkTitle":"2022 鐵人賽系列","RelPermalink":"/categories/2022-%E9%90%B5%E4%BA%BA%E8%B3%BD%E7%B3%BB%E5%88%97/"}],"content":"到了中午，當我們不知道要吃什麼，就會想要到 google 搜尋附近有哪些餐廳，然後在網頁中的搜尋欄輸入關鍵字，按下 Enter 後，就會出現查詢結果。\n那在上述的情境中，網路是如何處理這樣子的流程呢？這就要從 HTTP 的 Request 和 Response 開始說起了。\nRequest/Response 是什麼？ 從上面這張圖可以看到，當我們想要透過網站獲得一些資料時，甚至是打開網頁的時候，其實就是在向網站的伺服器提出請求。圖中的 Request 代表使用者這邊所提出的請求，而 Response 則代表伺服器回傳的資訊，其中，這些資料的資訊會透過「封包」去傳送。\n網頁上所顯示的不管是圖片、文字，都是由一個個封包所組成的，在我們打開網頁時，就已經在向伺服器發出 Request，伺服器回傳了許多的 Response，而這些 Response 組合出了我們所看到的畫面。\n這些封包被隱藏在網頁中，需要透過特別的工具去查看才有辦法看到，之後就會提到這個神奇的工具 — Chrome Developer Tool。\n","permalink":"https://example.com/posts/day2-%E7%B6%B2%E8%B7%AF%E6%98%AF%E5%A6%82%E4%BD%95%E5%82%B3%E9%81%9E%E8%B3%87%E6%96%99%E7%9A%84/","tags":[],"title":"Day2 - 網路是如何傳遞資料的？"},{"categories":[{"LinkTitle":"2022 鐵人賽系列","RelPermalink":"/categories/2022-%E9%90%B5%E4%BA%BA%E8%B3%BD%E7%B3%BB%E5%88%97/"}],"content":"(先來個開場白幹話)\n網路大家每天都在使用，可以隨時方便地到達各個網站搜尋或是購買各種需要的東西，但這個每天幾乎無時無刻使用的工具，你真的知道他背後的運作原理嗎？其實網路背後也暗藏許多秘密。\n這次以「網路」作為鐵人賽的題目，不僅是為了讓自己複習這些比較底層，但其實很重要的知識，也是為了能和目前正在學習網頁設計的各位一起學習。\n這篇主要會以網頁開發初學者的角度去了解網路的架構以及應用，以及了解在這條路上會需要學習哪些必備知識，是以學習\u0026quot;網站開發\u0026quot;這類型的人比較適合看這篇喔！也算是幫自己做個複習。\n因為是偏向應用方面，所以介紹一些概念和名詞的同時，也會加入一些實作的練習！而像是關於網路協定的歷史、OSI 模型、寬頻……等的比較底層的知識，這邊就不會提到太多了，怕大家會看到睡著。\n有興趣的話可以到 我的 iThome 帳號\r看看我發表的文章喔～\n","permalink":"https://example.com/posts/day1-%E5%89%8D%E8%A8%80/","tags":[],"title":"Day1 - 前言"},{"categories":[{"LinkTitle":"Vue","RelPermalink":"/categories/vue/"}],"content":"這篇會介紹 Vuex 的基本名詞以及他們的差異！\n在撰寫 Vue 專案的過程中，時常會遇到多個檔案需要使用同樣變數的情況，而變數雖然可以透過 props 或 emit 的形式來傳遞，但卻也變得麻煩許多。\n因此，這時候就出現了 Vuex 來解決這個問題！\n目錄 State 儲存全域變數的地方 state: { count: 0 } Mutation 能改變state的唯一一個地方 函式形式 mutation: { increment(){ state.count++;//直接改變state裡的變數 } } Action 在 .vue 裡可以用 store.dispatch()的方式呼叫這邊的函式 函式形式 action: { increment (context) { context.commit(\u0026#39;increment\u0026#39;)//會做mutation的函式 } } Vue2 和 Vue3 生命週期名稱的差異 ","permalink":"https://example.com/posts/vuex-%E4%BB%8B%E7%B4%B9/","tags":[],"title":"Vuex 介紹"},{"categories":[{"LinkTitle":"VScode","RelPermalink":"/categories/vscode/"}],"content":"前言 在用 vscode 寫網頁時，常常會出現這樣的提示框\n下面來講講怎麼關掉這些提示框～\n步驟 在 vscode 的左下角有個設定的符號，點進去 點選第二行的「設定」 在關鍵字尋找「editor.hover」，然後框起來的部分不勾選 再尋找「parameter hints」，框起來的部分也是不勾選 最後將 vscode 重開就行了～\n","permalink":"https://example.com/posts/%E5%A6%82%E4%BD%95%E5%B0%87-vscode-%E7%9A%84%E6%8F%90%E7%A4%BA%E6%A1%86%E9%97%9C%E9%96%89/","tags":[],"title":"如何將 VScode 的提示框關閉"},{"categories":[{"LinkTitle":"Vue","RelPermalink":"/categories/vue/"}],"content":"本篇會介紹 Vue 環境的安裝及建立！\nEnvironment: Ubuntu\n安裝 npm(Node Package Manager) :::info 要確認裝的版本是 12 or 14以上（最新版本是 17） 用 14 就好了 ::: sudo apt-get install nodejs npm 確認有裝好：\nnpm -v 安裝 Vue-cli npm install -g @vue/cli 確認有裝好：\nvue -v :::danger\n採過的坑： 如果打\nsudo npm install -g @vue/cli 會跳出以下的錯誤訊息：\nmodule.js:339\rthrow err;\r^\rError: Cannot find module \u0026#39;semver\u0026#39;\rat Function.Module._resolveFilename (module.js:337:15)\rat Function.Module._load (module.js:287:25)\rat Module.require (module.js:366:17)\rat require (module.js:385:17)\rat Object.\u0026lt;anonymous\u0026gt; (C:\\Users\\admin\\AppData\\Roaming\\npm\\node_modules\\npm\\l\rib\\config\\defaults.js:6:14)\rat Module._compile (module.js:435:26)\rat Object.Module._extensions..js (module.js:442:10)\rat Module.load (module.js:356:32)\rat Function.Module._load (module.js:311:12)\rat Module.require (module.js:366:17) 好像是路徑問題 :::\n建立新的 vue 專案 vue create \u0026lt;project_name\u0026gt; :::success 之後會出現兩個網址，挑一個放到瀏覽器上就能進入專案畫面了\nDONE Compiled successfully in 7110ms 1:45:54 PM\rApp running at:\r- Local: http://localhost:8080/ - Network: http://xxx.xx.xx.x:8080/\rNote that the development build is not optimized.\rTo create a production build, run npm run build. :::\n查詢專案的vue版本 npm list vue HelloWorld.vue!!!!! 千萬別刪，專案會壞掉 ","permalink":"https://example.com/posts/create-a-vue-project/","tags":[],"title":"Create a Vue project!"},{"categories":[{"LinkTitle":"2022","RelPermalink":"/categories/2022/"}],"content":"這篇會介紹 Cypress 的安裝和使用方法！\nversion 10.3.1\n安裝 官方文件\r% npm install cypress --save-dev 安裝後就能看到 cypress 目錄了\n開啟環境 % npx cypress open 之後會出現下面的視窗，有 E2E Testing 和 Component Testing 兩種測試方法 E2E Testing：模擬使用者使用網站 Component Testing：檢查程式碼中元件的問題 再點選其中一個瀏覽器就能打開 Cypress 的測試環境了\n進入瀏覽器後可以看到 cypress 中所有的測試檔案\n點選測試檔進去後就會開始執行測試，右邊的畫面可以看到實際測試網頁的過程\n目錄架構 整個架構都可以在外面的編輯器撰寫，像是 VScode。然後檔案在編輯器撰寫的話，會發現 Cypress 和 cy 會因為沒有定義而報錯，但這不影響\nsupport：寫自定義方法，類似函式 e2e.js：support 目錄的 root\n目前寫好的函式結構：\ncommands.js：Login/Logout formActions.js：對表單會使用到的基本操作 baseAction.js：對基本動作(ex:click,type…)加上 {force:true} 操作方法\n//In /support Cypress.Commands.add(\u0026#39;Login\u0026#39;, (data) =\u0026gt; { cy.visit(\u0026#39;http://localhost:8080\u0026#39;) cy.get(\u0026#39;input[placeholder=\u0026#34;請填入帳號\u0026#34;]\u0026#39;) .type(data.account) cy.get(\u0026#39;input[placeholder=\u0026#34;請填入密碼\u0026#34;]\u0026#39;) .type(data.password) cy.get(\u0026#39;button\u0026#39;) .contains(\u0026#39;Login\u0026#39;) .click() }); //In /e2e cy.Login({account:\u0026#39;admin\u0026#39;, password:\u0026#39;admin123!\u0026#39;}) fixtures：存放測試資料，json 格式 和其對應的函式: cy.fixture()\re2e：存放測試腳本 檔案格式都是 .cy.js 結尾\n腳本主架構 describe(\u0026#39;My First Test\u0026#39;, ()=\u0026gt;{ before(()=\u0026gt;{...}); beforeEach(()=\u0026gt;{...}); describe(\u0026#39;My First Test\u0026#39;, ()=\u0026gt;{ }) it(\u0026#39;Login\u0026#39;, ()=\u0026gt;{ context(\u0026#39;\u0026#39;, ()=\u0026gt;{ }) }); it(\u0026#39;\u0026#39;, ()=\u0026gt;{...}); . . . it(\u0026#39;\u0026#39;, ()=\u0026gt;{...}); it(\u0026#39;\u0026#39;, ()=\u0026gt;{...}); after(()=\u0026gt;{...}); afterEach(()=\u0026gt;{...}); }) it(): 撰寫測試內容的地方，會把瀏覽器資料清空\n測試以外的內容\n比較 before beforeEach afterEach after 執行順序 1 2 3 4 執行時間 it()前 it()前 it()後 it()後 執行次數 一次 it()次數決定跑幾次 it()次數決定跑幾次 一次 describe()和context() 功能是一樣的，裡面可以包很多小測試檔，可視為一個測試的群組，這兩個要放哪都可以 指令 官方文件\r每句指令前面都會加上\u0026quot;cy.\u0026quot;\n每行指令(cy.開頭)抓取的元素都是獨立的，寫到下一行就會重新抓取元素 // 如果想在 input 中輸入 admin // Correct cy.get(\u0026#39;input[placeholder=\u0026#34;請填入帳號\u0026#34;]\u0026#39;).type(\u0026#34;admin\u0026#34;) // Wrong cy.get(\u0026#39;input[placeholder=\u0026#34;請填入帳號\u0026#34;]\u0026#39;) cy.type(\u0026#34;admin\u0026#34;) cy.visit(): 造訪網頁 cy.visit(\u0026#39;http://10.40.192.174:8080\u0026#39;) cy.get(): 抓取DOM元素 通常是取元素的 ID 或 Class 去取得元素，但如果兩者都沒有，也可以使用只有該元素具有的特徵來抓取\ncy.get(\u0026#39;#main\u0026#39;)//抓取 ID 為 main 的元素 cy.get(\u0026#39;.btn1\u0026#39;)//抓取 Class 為 btn1 的元素 cy.get(\u0026#39;input[placeholder=\u0026#34;請填入帳號\u0026#34;]\u0026#39;)//抓取 placeholder 為 \u0026#39;請填入帳號\u0026#39; 的 input cy.contains(): 透過元素呈現在網站上的文字尋找該元素 cy.contains(\u0026#39;Account\u0026#39;)//尋找含有\u0026#39;Account\u0026#39;這個字的元素 cy.type(\u0026lsquo;要輸入的文字\u0026rsquo;): 在輸入框中輸入文字 cy.fixture(\u0026rsquo;\u0026rsquo;): 引用 /fixtures 中的資料 fixture() 代表會抓 /fixtures 目錄下的資料，參數是檔名(副檔名可加可不加)\ncy.fixture(\u0026#39;data\u0026#39;).then((users) =\u0026gt; { cy.get(\u0026#39;.el-textarea__inner\u0026#39;).type(users.name) }) 如果參數放的是 \u0026lsquo;admin\u0026rsquo;，但 /fixtures 中有很多筆開頭為 admin 的檔案，會對應找到的第一個檔案\ncy.wait()：暫停腳本測試，參數可放需暫停毫秒數 .as()：做個 alias 給抓到的資料or元素，有點像變數 Cypress 系列 官方文件\r這種形式的函式會寫在 /support 底下，而且所有測試腳本都會被連結到 ex:\nCypress.Commands.add Cypress.on：Uncaught exception 遇到的問題 主控台只要一出現錯誤訊息，Cypress 就會視為測試失敗\n解決方法： 想要跳過錯誤訊息，可以在 describe() 中加入以下程式碼，這樣就能無視錯誤訊息了 耶 Cypress.on(\u0026#39;uncaught:exception\u0026#39;, (err, runnable) =\u0026gt; { return false }) ","permalink":"https://example.com/posts/cypress-%E4%BD%BF%E7%94%A8/","tags":[{"LinkTitle":"Note","RelPermalink":"/tags/note/"},{"LinkTitle":"Cypress","RelPermalink":"/tags/cypress/"}],"title":"Cypress 使用"},{"categories":[{"LinkTitle":"Github","RelPermalink":"/categories/github/"}],"content":"情境如下： 如果遠端有人 push 了新的版本，但本地這邊現在也有不一樣的版本正在進行，現在你想要合併本地和遠端兩個版本。 因為一個分支沒辦法在有未修改檔案(也就是還沒 commit)的狀況下更新遠端進度，所以要先開一個新的分支去 commit 本地端的檔案。 git branch \u0026lt;new branch name\u0026gt; :::info 如果之前已經有開過分支了，也可以拿那些分支來使用喔！ 但要注意的是分支落後太多進度的話沒辦法就再使用了。 :::\n開好新分支後，就在新分支 commit 你剛剛修改的檔案，然後再回到原來的分支去 pull 遠端分支，然後再 merge 新分支的版本\n總結來說，全部的流程就是：\ngit branch \u0026lt;new branch name\u0026gt; git checkout \u0026lt;new branch name\u0026gt; git add . git commit -m \u0026#34;commit message\u0026#34; git checkout \u0026lt;previous branch name\u0026gt; git pull git merge \u0026lt;new branch name\u0026gt; ","permalink":"https://example.com/posts/github-%E8%A7%A3%E6%B1%BA%E6%9C%89%E8%A1%9D%E7%AA%81%E7%9A%84%E5%88%86%E6%94%AF%E5%90%88%E4%BD%B5/","tags":[],"title":"Github 解決有衝突的分支合併"},{"categories":[{"LinkTitle":"架站","RelPermalink":"/categories/%E6%9E%B6%E7%AB%99/"}],"content":"最近終於把買好的網域連到個人網站上，趕緊來寫一篇心得怕忘記，不過每個人買網域的機構都不太一樣，我是在 pchome 上買的，步驟可能也會不太一樣喔～\n目錄 買網域 我當初會到 pchome 買網域，主要是因為他相對其他機構會比較便宜。這邊我就不細講買網域的流程，google 搜尋「pchome 買網址」這個關鍵詞就能找到很多資訊！\n將網域連接至架設好的網站 我的網站是放到 Github Pages 展示的，不是使用這個方法的可以略過這一段\n我在另一篇\r有介紹怎麼把靜態網頁放到 Github 上展示，有興趣的可以看看\n首先進入放個人網站的 Github repository，點選上面的「Settings」 再來點選「Pages」，在「Custom Domain」的地方填入你所購買的網域 DNS 代管方式 網域連接好了，不代表在瀏覽器上就能看到個人網站，還需要以下幾個步驟\n這邊介紹兩種方法：\n1. Pchome 代管 進入「管理我的網址」-\u0026gt;「DNS 設定與修改」-\u0026gt; 點選「進入」 點選「PChome 代管 DNS」，此時你就會看到以下畫面： 類型記得先點選「A(ipv4)」\n那問題來了，中間的地址應該要填什麼呢？ 這時候就要使用以下其中一個指令，來查詢你的網域的 ip\nnslookup\ndig\n將框起來的 ip 填入 PChome 的「地址」部分就可以了。\n再來是前面的「主機/次網域」，可填可不填，假設你填了 www，到時候你的網址開頭就會多出 www\n後面兩欄不用理他，再來按下「送出」，等待ㄧ至兩天，之後在瀏覽器打上你的瀏覽器檢查看看有沒有成功就行了！\n2. Cloud Flare 代管 使用 Cloud Flare 代管的好處是，他可以設定將比 Pchome 多了 https 這一層保護\n首先先註冊 Cloud Flare 成功後就會看到右上角的地方有個「Add site」 點進去後，輸入你所購買的網域名稱 然後你就會看到你的 ip 列表，點選下一步，他會給你兩個 NS(Name Server)，複製後進行下一步 回到pchome的「設定DNS」，選擇「自管DNS」，將這兩個 NS 填入 大功告成！\n","permalink":"https://example.com/posts/%E5%B0%87%E7%B6%B2%E5%9F%9F%E9%80%A3%E5%88%B0%E5%80%8B%E4%BA%BA%E7%B6%B2%E7%AB%99pchome-cloudflare/","tags":[],"title":"將網域連到個人網站 (Pchome+CloudFlare)"},{"categories":[],"content":"說了好久的部落格，我終於把它建起來了…(淚\n網域都買了幾個月了，現在才用真的慚愧。\n就以建這個 Blog 的筆記作為第一篇文吧～\n使用 Hugo 建立一個 Blog \u0026lt;內容…\u0026gt;\n","permalink":"https://example.com/posts/%E4%BD%BF%E7%94%A8-hugo-%E5%BB%BA%E7%AB%8B%E4%B8%80%E5%80%8B-blog/","tags":[],"title":"使用 Hugo 建立一個 Blog"},{"categories":[],"content":"自介 哈囉我是莊淑涵 Bernice，在這個網站想紀錄一些學習過的工具或知識，當作是個紀念以後忘了也可以回來複習。\n大學時期是以前端開發的筆記為主，這時候學的主要是 Vue。\n到碩士階段則會探討深度學習的文獻為主，學習領域偏向電腦視覺，但其實各種 AI 都會碰。\n","permalink":"https://example.com/about/","tags":[],"title":""},{"categories":[],"content":"","permalink":"https://example.com/search/_index.es/","tags":[],"title":""},{"categories":[],"content":"","permalink":"https://example.com/search/_index.fr/","tags":[],"title":""},{"categories":[],"content":"","permalink":"https://example.com/search/_index.hi/","tags":[],"title":""},{"categories":[],"content":"","permalink":"https://example.com/search/_index.jp/","tags":[],"title":""},{"categories":[],"content":"","permalink":"https://example.com/search/_index.pl/","tags":[],"title":""},{"categories":[],"content":"","permalink":"https://example.com/search/_index.ru/","tags":[],"title":""},{"categories":[],"content":"","permalink":"https://example.com/search/_index.zh-cn/","tags":[],"title":""}]